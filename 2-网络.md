# 一、[概述](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%A6%82%E8%BF%B0.md)

**OSI**（开放式系统互连参考模型）是一种通信协议的7层抽象的参考模型，其中每一层执行某一特定任务。该模型的目的是使各种硬件在相同的层次上相互通信。 分为七层结构：**应用层、表示层、会话层、传输层、网络层、数据链路层、物理层**。TCP/IP协议并不完全符合OSI模型。 

- [物理层](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%89%A9%E7%90%86%E5%B1%82.md)
- [链路层](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E9%93%BE%E8%B7%AF%E5%B1%82.md)
- [网络层](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md)
- [传输层](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md)
- [应用层](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82.md)



# 二、TCP/IP协议栈

TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构：**应用层、传输层、网络层、链路层**。

|   4层模型   | 相关的网络协议 | 职责 |
| ---- | ---- | ---- |
| 应用层 | HTTP、NTP、DNS、TELNET、FTP、TFTP、SMTP、RTSP、P2P | 定义数据格式，并按照对应的格式解读数据。 |
| 传输层 | TCP（传输控制协议）、UDP（用户数据报协议） | 定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序。 |
| 网络层 | IP（网际协议）、ICMP（互联网控制报文协议） | 定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发。 |
| 链路层 | ARP（地址解析协议） | 对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据。 |

[深入浅出 TCP/IP 协议栈](https://www.cnblogs.com/onepixel/p/7092302.html)：当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。



## [TCP的三次握手/四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)

![](http://dl2.iteye.com/upload/attachment/0077/6058/5d4e8c89-fc42-3862-bdb8-399bc982f410.png)

* CLOSE_WAIT状态 
发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。
* TIME_WAIT状态 
根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态。TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟，即240秒。TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。



# 三、应用层协议

HTTP协议（超文本传输协议）、NTP协议（网络时间协议）、TELNET协议（虚拟终端协议）、DNS协议(域名解析协议)、FTP协议（文件传输协议）、TFTP协议（简单文件传输协议）、SNMP协议（简单网络管理协议）、SMTP协议（简单邮件传输协议）、POP协议（邮局协议）、RTSP（实时流传输协议）、DHCP（动态主机配置协议）、P2P

## [HTTP/HTTPS](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md)

超文本传输安全协议（Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS）是一种网络安全传输协议。先来介绍一下以前常见的HTTP，HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文，因此使用HTTP协议传输隐私信息非常不安全。HTTP使用80端口通讯，而HTTPS占用443端口通讯。HTTPS经由超文本传输协议（HTTP）进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。

- **Cookie**是浏览器里面能永久存储的一种数据，是浏览器实现的一种数据存储功能。cookie由服务器生成，发送给浏览器，浏览器把Cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。

- **Session**就是会话，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。客户端默认采用Cookie方式保存“身份标识”；服务器通过session把用户的信息临时保存在了服务器上，用户离开后session会被销毁。

- **Token**是用户身份的验证方式。客户端成功登陆服务器后，服务器会签发一个Token，客户端收到Token后存储起来（Cookie）。客户端的每次请求都带上Token，服务器收到后校验成功后，返回响应。



**参考资料：**

- [HTTP 状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Response_codes)

- [HTTPS协议、TLS协议、证书认证过程解析](https://www.cnblogs.com/snowater/p/7804889.html)

- [HTTPS原理与证书生成](https://itimetraveler.github.io/2018/10/30/HTTPS%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AF%81%E4%B9%A6/#TLS%E5%8E%86%E5%8F%B2)

- [Https单向认证和双向认证](https://blog.csdn.net/duanbokan/article/details/50847612)



# 四、网络安全

- **不可逆加密 - 单向散列函数**（MD5、SHA）：根据消息内容计算出 散列值/摘要/哈希值，计算出的散列值长度固定，与消息长度无关。
  - 应用：账户注册时，数据库存储的数据是加密后的散列值；账户登陆时，先将密码计算出散列值，再通过网络发送至服务器。
- **可逆加密 - 对称加密**（DES、3DES、AES）：加密与解密使用的密钥相同。
  - 密钥配送问题：通过非对称加密方式，将对称加密的密钥进行加密后发送。
- **可逆加密 - 非对称加密**（RSA）：加密与解密使用的密钥不同。
  - 加密密钥：一般是公开的，也称为**公钥**。
  - 解密密钥：由消息接受者保管，也称为**私钥**。
  - 公钥和私钥是对应的，不能单独生成，由公钥加密的密文，必须使用与该公钥对应的私钥才能解密。
- **混合密码系统**：对称加密的缺点是不能解决密钥配送问题，非对称加密的缺点是加解密速度慢，混合密码系统将对称加密和非对称加密的优势结合。网络上的密码通信系统所用的SSL/TLS都运用了混合密码系统。
  - 会话密钥：作为本次通信随机生成的临时密钥，作为对称加密的密钥，用于加密消息，提高速度。
- **数字签名**：识别消息的篡改、伪装、否认。
  - 生成签名：由消息发送者完成，通过“签名密钥”生成。先将消息生成加密生成散列值，再用私钥进行加密生成签名，与消息一并发送。
  - 验证签名：由消息接收者完成，通过“签名密钥”验证。先将消息生成加密生成散列值，将收到的签名用公钥进行解密得到原始散列值，与生成的散列值进行比对验证。
- **证书**：密码学中的证书全称叫公钥证书，证明公钥拥有者身份的凭证。证书里面包含个人信息 + 个人公钥，由由权威认证机构CA施加数字签名。CA是能够认定公钥确实属于此人并能够生成数字签名的个人或组织。
  - 解决中间人攻击场景，篡改发送公钥窃听消息的问题。
- **认证** identification 是指根据声明者所特有的识别信息，确认声明者的身份。
- **授权** authorization 是指获取用户的委派权限。
- **鉴权** authentication 是指对于一个声明者所声明的身份权利的真实性进行鉴别确认的过程。
  - [4种常见的鉴权方式](https://blog.csdn.net/sinat_33255495/article/details/103920131)



# 网络基础概念

## MAC地址

每张网卡都有一个6字节（48bit）的MAC地址，固化在网卡ROM中，由IEEE802标准规定，在网络底层的物理传输过程中，数据传输是通过物理地址来识别主机的，它一定是全球唯一的。前三个字节：组织唯一标识符，由IEEE的注册管理机构分配给厂商；后三个字节：网络接口标识符，由厂商自行分配。

## IP地址

| IP地址  | 子网掩码      | 最高位 | 范围                        |
| ------- | ------------- | ------ | --------------------------- |
| A类地址 | 255.0.0.0     | 0      | 1.0.0.0 - 127.255.255.255   |
| B类地址 | 255.255.0.0   | 10     | 128.0.0.0 - 191.255.255.255 |
| C类地址 | 255.255.255.0 | 110    | 192.0.0.0 - 223.255.255.255 |

* IP地址由**网络地址**和**主机地址**组成，可划分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。
* 在计算机网络中，主机ID全部为0的地址为网络地址，而主机ID全部为1的地址为广播地址，这2个地址是不能分配给主机用的。
* 两台主机要通信，首先要判断是否处于同一**网段**，即网络地址是否相同（网络地址 = IP地址 & 子网掩码  ）。如果相同则把数据包直接发送到目标主机；否则就需要路由网关将数据包转发送到目的地。**网关**就是到其他网段的出口，也就是路由器接口的IP地址。


## [计算机之间的连接方式](https://blog.csdn.net/qq_38975553/article/details/110166561)

- 网线直连
- 同轴电缆
- 集线器(Hub)
- 网桥(Bridge)
- 交换机(Switch)
  - 相当于接口更多的网桥
  - 全双工通信
  -  比集线器更安全
  - 连接的设备必须在同一网段, 即处在同一广播域
- 路由器(Router)
  - 可以在不同网段之间转发数据
  - 隔绝广播域

## 抓包工具

[Wireshark学习](https://www.kancloud.cn/digest/wireshark/62470)

[tcpdump 抓包使用小结](https://wsgzao.github.io/post/tcpdump/)

## 大小端字节序

主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。数据存放到内存，都是由低地址到高地址。32 位整数 `0x12345678` 是从起始位置为 `0x00` 的地址开始存放，则：

| 内存地址                       | 0x00 | 0x01 | 0x02 | 0x03 |
| ------------------------------ | ---- | ---- | ---- | ---- |
| 大端：先存储高位字节数据 ARM   | 12   | 34   | 56   | 78   |
| 小端：先存储低位字节数据 Intel | 78   | 56   | 34   | 12   |

