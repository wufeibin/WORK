# 一、编译链接


## 编译系统


一个 hello.c 程序，在 Unix 系统上，由编译器把源文件转换为目标文件。

```bash
gcc -o hello hello.c
```

这个过程大致如下：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>

1. 预处理：替换inclue内容，宏定义， gcc –E hello.c –o hello.i
2. 编译：生成汇编代码，gcc –S hello.i –o hello.s
3. 汇编：生成机器代码，gcc –c hello.s –o hello.o
4. 链接：链接目标文件，gcc hello.o –o hello

## 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- **符号解析**：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- **重定位**：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>

静态链接使开发者能够相对独立地开发测试程序模块，但随着程序规模扩大，静态链接出现**浪费内存和磁盘空间、模块更新困难**等缺点。

- 静态库编译

  ```
  g++ -c hello.cpp
  ar -crv libhello.a hello.o
  g++ -c main.cpp -L./libpath -lhello
  ```

## 动态链接

为了解决静态链接空间浪费和更新困难的问题，动态链接的基本思路是，把程序拆分成各个相对独立的模块，在运行时进行链接。运行时根据程序的依赖关系，将需要的目标文件（动态库）全部加载到内存中；若依赖关系满足，系统开始进行链接工作（符号解析、地址重定位）；链接后再将控制权交到程序入口处。

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，不会被复制到引用它的可执行文件中。
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>

- **装载时动态链接**：使用头文件，类似静态库的调用，编译时链接库，会在程序启动时完成加载。

  - 静态链接器：生成部分链接的可执行目标文件，在编译链接时，添加依赖动态库的信息，生成目标文件包含一些重定位和符号表信息 ，可用ldd查看。

  - 动态链接器：生成完全链接的可执行文件，程序开始运行时装载建立链接关系。程序运行时若缺少或无法找到动态库，运行失败报错。
  
- **运行时动态链接**：不使用头文件，通过dlopen/dlsym加载动态库。
  
  - 插件：按照一定的规则制定好程序的接口，其他开发者以接口规范来编写符合要求的动态链接文件，程序运行时可以动态地选择加载各种插件，实现程序功能的扩展。
  
- **静态/动态链接区别**：静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。而动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息），仅当应用程序被装入内存开始运行时建立链接关系。

- 动态库编译

  ```
  g++ -fPIC -shared helo.cpp -o libhello.so
  g++ -c main.cpp -L./libpath -lhello
  ```


- 编译时只是把函数的符号地址记录下来，链接时该函数符号有定义才会变成具体的地址。如果链接过程中所有使用的符号都有定义，链接成功，生成可执行文件；否则链接失败。 
- 一个只声明未定义的库文件函数，模块引用编译会失败报错，模块不引用编译成功。链接阶段只查找使用的符号定义，未使用的符号不查找
- 编译动态库，只需要有声明；编译可执行文件，需要声明加定义

## 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

## 共享库

- 共享库版本命名：libname.so.x.y.z
  - x 主版本号：重大升级，不兼容
  - y 次版本号：增量升级，新增接口符号，原有符号不变
  - z 发布版本号：错误修正，性能改进，完全兼容
- SO-NAME：只保留主版本号。Linux系统中会为每个共享库所在的目录创建一个跟SO-NAM同名的并指向它的软链接。
- 共享库系统路径
  - /lib：存放系统最关键最基础的共享库，如动态链接器、C运行库、数学库
  - /usr/lib：存放非系统运行时的关键性共享库，一般不会被用户程序直接使用
- 共享库查找过程
  - 动态链接器会在 /lib 和 /usr/lib 和 /etc/ld.so.conf 配置文件指定路径查找共享库。
  - 通过LD_LIBRARY_PATH环境变量，临时改变程序的共享库查找路径。



# 二、[Makefile](https://seisman.github.io/how-to-write-makefile/)

make先找到makefile中的第一个目标文件，一层层去找target的依赖关系，执行command，最终编译出第一个目标文件。



**编译选项：**[常用GCC编译参数](https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/)

- -o 指定目标文件名称
- -c 生成目标文件
- -g 生成编译信息
- -O 优化生成代码
- -Wall 生成所有告警信息
- -I 指定额外的头文件搜素路径
- -L 指定额外的库搜索路径
- -l 指定链接的库名
- -M 生成文件关联的信息
- -share 生成共享目标文件
- -fPIC 生成位置独立的代码，编译共享库时需要
- -pipe 使用管道代替编译中的临时文件



**常见字符：**

- @ 不打印命令，只打印结果
- % 匹配到若干个字符，给%赋值。%.o:%.c，找出匹配的所有的.o和.c文件
- $@ 目标文件
- $^ 所有的依赖文件
- $< 第一个依赖文件
- := 只能使用前面已定义的变量来赋值
- ?= 赋值一个新的变量，若变量已定义则不处理
- += 追加变量值
- CFLAGS C编译器参数
- CXXFLAGS C++编译器参数
- LDFLAGS 链接器参数
- .PHONY 伪目标，可开头声明一个all的伪目标，依赖多个目标，实现一次生成多个目标
- include 引用其他Makefile
- $(MAKE) -C subdir，进入subdir嵌套执行make命令
- strip函数，去掉字符串头尾的空字符，合并中间的连续空字符为一个空字符
- addprefix函数，给字符加前缀



**编译错误：**

- 未声明：undeclared identifier

- 未定义：Undefined symbols



## [CMAKE](https://blog.csdn.net/zhanghm1995/article/details/80902807)



# 三、GDB

| GDB命令                        | 作用                                       |
| :------------------------------: | :------------------------------------------: |
| break file:line                | 设置断点                                   |
| break function                 | 设置断点                                   |
| break ... if ...               | 设置条件断点                               |
| info breakpoints               | 查看当前设置了哪些断点                     |
| delete breakpoints             | 删除断点                                   |
| enable/disable breakpoints     | 启用/禁用断点                              |
| display                        | 跟踪查看某个变量，每次遇到断点都显示它的值 |
| command	breakpoints ··· end | 为断点设置运行命令                         |
| run                            | 从头开始连续运行程序                       |
| continue                       | 从当前位置开始连续运行程序                 |
| next                           | 执行下一行语句                             |
| step                           | 执行下一行语句，若有函数调用则进入到函数中 |
| finish                         | 运行到当前函数返回为止                     |
| backtrace                      | 查看各级函数调用及参数                     |
| t ..                           | 跳转到指定线程                             |
| f ..                           | 跳转到指定栈帧                             |
| info locals                    | 查看当前栈帧局部变量的值                   |
| info args                      | 查看当前函数入参的值                       |
| info r                         | 查看寄存器的值                             |
| print                          | 打印表达式的值                             |
| disassemble                    | 打开该帧函数的反汇编代码                   |
| examine(x)                     | 按字节打印某个地址中开始的值               |
| info thread                    | 查看所有线程信息                           |
| thread apply all bt            | 打印所有线程堆栈                           |
| gdb attach pid                 | 挂载gdb至进程                              |
| gstack pid                     | 打印进程全部堆栈                           |



# 四、CoreDump

## 1. 前言

作为一个Linux软件开发人员，经常会遇到类似下面的问题：

```
Segmentation fault (core dumped)
```

这种问题就是程序崩溃。这种问题经常会让人很崩溃，特别当它的堆栈如下情况，更加让人崩溃：

```
(gdb) bt
#0  0x6f745374 in ?? ()
#1  0x57735571 in ?? ()
#2  0xbff80065 in ?? ()
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
```

这种问题往往会带来很多麻烦：

1. 这种问题有可能非常难重现

2. 这种问题的相关信息非常少，有可能只有一个core文件。

3. 它需要很深厚的功底才能够找出它的根因

## 2. coredump设置

### core文件开关

- ulimit -c ，查看core开关，0位关闭
- ulimit -c [filesize] ，设置core文件大小
- ulimit -c unlimited ，设置core文件大小不限制

- 作用于当前shell：直接在shell执行设置
- 作用于单个用户：~/.bash_profile文件中添加设置
- 作用于所有用户：/etc/profile文件中添加设置

### core文件命名和保存路径

通过 **/proc/sys/kernel/core_pattern** 设置 core 文件名和保存路径，方法如下：

`echo "/corefile/core-%e-%p-%t" > /proc/sys/kernel/core_pattern`

命名的参数列表： 

- %p - insert pid into filename 添加pid 
- %u - insert current uid into filename 添加当前uid 
- %g - insert current gid into filename 添加当前gid 
- %s - insert signal that caused the coredump into the filename 添加导致产生core的信号 
- %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间 
- %h - insert hostname where the coredump happened into filename 添加主机名 
- %e - insert coredumping executable name into filename 添加命令名

### core文件调试

`gdb [execfile] [corefile]` 或 `gdb -c [corefile]` + `file [execfile]`

- info sharedlibrary
- solib-absolute-prefix ，设置符号文件路径的前缀
- set solib-search-path ，设置符号文件路径，多个路径以:分隔
- add-symbol-file [符号表文件] [地址]
- set print pretty
- info locals ，打印该帧函数局部变量
- p *this ，打印当前类对象所有成员
- info thread ，查看所有线程信息
- thread apply all bt ，打印所有线程堆栈
- disassemble ，打开该帧函数的反汇编代码
- examine(x) ，按字节打印某个地址中开始的值

## 3. coredump场景


- **内存访问越界**

  - 数组访问越界
  - 字符串操作越界
- **非法指针**

  - 使用空指针
  - 使用已释放的指针，重复释放内存
  - 指针类型转换错误
- **栈溢出**：使用了大的局部变量，造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。
- **多线程读写的数据未加锁保护**：对于会被多个线程同时访问的全局数据，应该注意加锁保护。
- **多线程程序使用了线程不安全的函数**

踩内存：上述情况都可能导致内存被踩，访问了异常的内存地址，程序崩溃。一般发生在内存被踩后，对象释放和新对象申请时。
