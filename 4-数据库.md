# 一、简介

数据库是按照数据结构来组织、存储和管理数据的仓库。

## 关系型数据库

概念：采用了关系模型来组织数据的数据库。**SQLite、Mysql、Oracle、PostgreSQL**

特点：数据以表格的形式出现；每行为各种记录名称；每列为记录名称所对应的数据域；许多行和列组成一张表单；若干的表单组成database。

- 容易理解：二维表结构的关系模型相对网状、层次等其他模型来说更容易理解。
- 使用方便：通用的SQL语言使得操作关系型数据库非常方便。
- 易于维护：丰富的完整性（实体完整性、参照完整性和用户定义的完整性）大大减低了数据冗余和数据不一致的概率。

## 非关系型数据库

概念：非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。

特点：适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，关系型数据库显的更为合适。不适合持久存储海量数据。

- 面向高性能并发读写的key-value数据库：**Redis**
- 面向海量数据访问的面向文档数据库：**MongoDB**

## 比较

1. 成本：Nosql数据库简单易部署，基本都是开源软件，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。
2. 查询速度：Nosql数据库将数据存储于缓存之中，而且不需要经过SQL层的解析，关系型数据库将数据存储在硬盘中，自然查询速度远不及Nosql数据库。
3. 存储数据的格式：Nosql的存储格式是key-value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。
4. 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
5. 持久存储：Nosql不使用于持久存储，海量数据的持久存储，还是需要关系型数据库。
6. 数据一致性：Nosql一般强调的是数据最终一致性，不像关系型数据库一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，Nosql不提供对事务的处理。



# 二、[数据库系统原理](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md)



# 三、[SQL](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md)

structured query language 结构化查询语言，专门对数据库进行（CURD）查找、增加、修改、删除、统计的操作语言。书写风格：关键字大小写都行，建议大写；表名大小写都行，建议小写。

## 基本语法

```sql
-- 登录MySQL数据库服务器
mysql -uroot -pwufeibin

-- 退出MySQL数据库服务器
exit;
```

```sql
-- 显示所有数据库
show databases;

-- 创建数据库
create database test;

-- 切换数据库
use test;

-- 显示数据库中的所有表
show tables;

-- 创建数据表
CREATE TABLE pet (
    name VARCHAR(20),
    owner VARCHAR(20),
    species VARCHAR(20),
    sex CHAR(1),
    birth DATE,
    death DATE
);

-- 删除表
DROP TABLE pet;

-- 查看表结构
DESC pet;

-- 查询表
SELECT * from pet;

-- 插入表数据
INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);

-- 修改表数据
UPDATE pet SET name = 'squirrel' where owner = 'Diane';

-- 删除表数据
DELETE FROM pet where name = 'squirrel';
```

## SQL约束

SQL约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。

1. **非空约束 NOT NULL**：某列不能存储 NULL 值。

   ```sql
   -- 建表时添加非空约束
   CREATE TABLE user (
       id INT,
       name VARCHAR(20) NOT NULL
   );
   
   -- 移除非空约束
   ALTER TABLE user MODIFY name VARCHAR(20);
   ```

2. **唯一约束 UNIQUE**：某列的值必须唯一。

   ```sql
   -- 建表时添加唯一约束
   CREATE TABLE user (
       id INT,
       name VARCHAR(20),
       UNIQUE(name)
   );
   
   -- 添加唯一约束
   ALTER TABLE user ADD UNIQUE(name);
   ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;
   
   -- 移除唯一约束
   ALTER TABLE user DROP INDEX name;
   ```

3. **主键约束 PRIMARY KEY**：NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。

   ```sql
   -- 建表时添加主键约束
   CREATE TABLE user (
       id INT PRIMARY KEY,
       name VARCHAR(20)
   );
   
   -- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。
   CREATE TABLE user (
       id INT,
       name VARCHAR(20),
       password VARCHAR(20),
       PRIMARY KEY(id, name)
   );
   ```

4. **外键约束 FOREIGN KEY**：保证一个表中的数据匹配另一个表中的值的参照完整性。

   ```sql
   CREATE TABLE classes (
       id INT PRIMARY KEY,
       name VARCHAR(20)
   );
   CREATE TABLE students (
       id INT PRIMARY KEY,
       name VARCHAR(20),
       -- class_id 要和 classes 中的 id 字段相关联
       class_id INT,
       -- class_id 的值必须来自于 classes 中的 id 字段值
       FOREIGN KEY(class_id) REFERENCES classes(id)
   );
   ```

5. **默认约束 DEFAULT**：约束某个字段的默认值。

   ```sql
   CREATE TABLE user2 (
       id INT,
       name VARCHAR(20),
       age INT DEFAULT 10
   );
   ```


6. **自增约束 AUTO_INCREMENT**：由系统自动递增分配。

   ```sql
   CREATE TABLE user (
       id INT PRIMARY KEY AUTO_INCREMENT,
       name VARCHAR(20)
   );
   ```

## SQL查询

**准备数据**

```sql
-- 创建数据库
CREATE DATABASE select_test;
-- 切换数据库
USE select_test;

-- 创建学生表
CREATE TABLE student (
    no VARCHAR(20) PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    sex VARCHAR(10) NOT NULL,
    birthday DATE, -- 生日
    class VARCHAR(20) -- 所在班级
);

-- 创建教师表
CREATE TABLE teacher (
    no VARCHAR(20) PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    sex VARCHAR(10) NOT NULL,
    birthday DATE,
    profession VARCHAR(20) NOT NULL, -- 职称
    department VARCHAR(20) NOT NULL -- 部门
);

-- 创建课程表
CREATE TABLE course (
    no VARCHAR(20) PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    t_no VARCHAR(20) NOT NULL, -- 教师编号
    -- 表示该 tno 来自于 teacher 表中的 no 字段值
    FOREIGN KEY(t_no) REFERENCES teacher(no) 
);

-- 成绩表
CREATE TABLE score (
    s_no VARCHAR(20) NOT NULL, -- 学生编号
    c_no VARCHAR(20) NOT NULL, -- 课程号
    degree DECIMAL,	-- 成绩
    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值
    FOREIGN KEY(s_no) REFERENCES student(no),	
    FOREIGN KEY(c_no) REFERENCES course(no),
    -- 设置 s_no, c_no 为联合主键
    PRIMARY KEY(s_no, c_no)
);

-- 查看所有表
SHOW TABLES;

-- 添加学生表数据
INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');
INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');
INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');
INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');
INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');
INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');
INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');
INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');
INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');

-- 添加教师表数据
INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');
INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');
INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');
INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');

-- 添加课程表数据
INSERT INTO course VALUES('3-105', '计算机导论', '825');
INSERT INTO course VALUES('3-245', '操作系统', '804');
INSERT INTO course VALUES('6-166', '数字电路', '856');
INSERT INTO course VALUES('9-888', '高等数学', '831');

-- 添加添加成绩表数据
INSERT INTO score VALUES('103', '3-105', '92');
INSERT INTO score VALUES('103', '3-245', '86');
INSERT INTO score VALUES('103', '6-166', '85');
INSERT INTO score VALUES('105', '3-105', '88');
INSERT INTO score VALUES('105', '3-245', '75');
INSERT INTO score VALUES('105', '6-166', '79');
INSERT INTO score VALUES('109', '3-105', '76');
INSERT INTO score VALUES('109', '3-245', '68');
INSERT INTO score VALUES('109', '6-166', '81');

-- 查看表结构
SELECT * FROM course;
SELECT * FROM score;
SELECT * FROM student;
SELECT * FROM teacher;
```

**例子**

```sql
-- 查询 student 表的所有行
SELECT * FROM student;

-- 查询 student 表中的 name、sex 和 class 字段的所有行
SELECT name, sex, class FROM student;

-- 查询 teacher 表中不重复的 department 列
SELECT DISTINCT department FROM teacher;

-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）
SELECT * FROM score WHERE degree BETWEEN 60 AND 80;
SELECT * FROM score WHERE degree > 60 AND degree < 80;

-- 查询 score 表中成绩为 85, 86 或 88 的行
SELECT * FROM score WHERE degree IN (85, 86, 88);

-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行
SELECT * FROM student WHERE class = '95031' OR sex = '女';

-- 以 class 降序的方式查询 student 表的所有行
SELECT * FROM student ORDER BY class DESC;
SELECT * FROM student ORDER BY class ASC;

-- 以 c_no 升序、degree 降序查询 score 表的所有行
SELECT * FROM score ORDER BY c_no ASC, degree DESC;

-- 查询 "95031" 班的学生人数
SELECT COUNT(*) FROM student WHERE class = '95031';

-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）
SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);

-- 排序查询（LIMIT r, n: 表示从第r行开始，查询n条数据）
SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;

-- 查询某门课的平均成绩
SELECT AVG(degree) FROM score WHERE c_no = '3-105';
SELECT c_no, AVG(degree) FROM score GROUP BY c_no; -- GROUP BY: 分组查询

-- 模糊查询
SELECT * FROM score c_no LIKE '3%'; -- LIKE 表示模糊查询，"%" 是一个通配符，匹配 "3" 后面的任意字符。

-- 多表查询：查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。
SELECT name, c_no, degree FROM student, score 
WHERE student.no = score.s_no; -- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。
```



# 四、[MySQL](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md)



# 五、[Redis](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)



# 六、MongoDB

MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

