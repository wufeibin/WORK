
# OSI模型
OSI（开放式系统互连参考模型）是一种通信协议的7层抽象的参考模型，其中每一层执行某一特定任务。该模型的目的是使各种硬件在相同的层次上相互通信。 分为七层结构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层  
TCP/IP协议并不完全符合OSI。 


# TCP/IP协议栈

4层模型 | 相关的网络协议
--- | ---
链路层 | ARP（地址解析协议）
网络层 | IP（网际协议）、ICMP（互联网控制报文协议）
传输层 | TCP（传输控制协议）、UDP（用户数据报协议）
应用层 | HTTP、NTP、DNS、TELNET、FTP、TFTP、SMTP、RTSP、P2P

[深入浅出 TCP/IP 协议栈](https://www.cnblogs.com/onepixel/p/7092302.html)

TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。  
TCP/IP 协议采用4层结构：应用层、传输层、网络层、链路层。

每层模型的职责
* 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；
* 网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；
* 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
* 应用层：定义数据格式，并按照对应的格式解读数据。

总结：当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。

[tcpip四层模型](https://blog.csdn.net/woalss/article/details/79054524)

[当你输入一个网址](https://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html)

# TCP的三次握手/四次挥手
[TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)  
[TCP的状态时序图](http://dl2.iteye.com/upload/attachment/0077/6058/5d4e8c89-fc42-3862-bdb8-399bc982f410.png)  

统计TCP连接情况：`netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' `  
* CLOSE_WAIT状态  
发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。
* TIME_WAIT状态  
根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态。TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟，即240秒。TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。

# 应用层协议
HTTP协议（超文本传输协议）、NTP协议（网络时间协议）、TELNET协议（虚拟终端协议）、DNS协议(域名解析协议)、FTP协议（文件传输协议）、TFTP协议（简单文件传输协议）、SNMP协议（简单网络管理协议）、SMTP协议（简单邮件传输协议）、POP协议（邮局协议）、RTSP、P2P、dhcp


# IP地址
* IP地址分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。  
* 在计算机网络中，主机ID全部为0的地址为网络地址，而主机ID全部为1的地址为广播地址，这2个地址是不能分配给主机用的。
* 两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。如果相同则把数据包直接发送到目标主机；否则就需要路由网关将数据包转发送到目的地。
* 网关就是到其他网段的出口，也就是路由器接口IP地址。

[IP地址分类图](https://s1.51cto.com/images/blog/201805/04/d8edafebca5bbbf1d5bb35cef4156026.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)

IP地址 | 掩码 | 最高位 | 范围
--- | --- | --- | ---
A类地址 | 255.0.0.0 | 0 | 1.0.0.0 - 127.255.255.255
B类地址 | 255.255.0.0 | 10 | 128.0.0.0 - 191.255.255.255
C类地址 | 255.255.255.0 | 110 | 192.0.0.0 - 223.255.255.255


# Wireshark
[Wireshark学习](https://www.kancloud.cn/digest/wireshark/62470)  
[Wireshark基本介绍和学习TCP三次握手](https://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html)  

# socket
> 网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。
>
> 1. 服务端先通过socket()创建一个套接字，返回一个唯一描述符，再通过bind()把一个IP+端口绑定到套接字上，再调用listen()来监听这个套接字。
> 2. 客户端也通过socket()创建一个套接字，通过connect()指定地址向服务端发起连接请求。服务端监听接收到请求后，通过accept()完成连接。
> 3. 之后两端通过read()/write()或recv()/send()进行I/O操作，结束后close()关闭套接字。

* int **socket**(int domain, int type, int protocol);	
* int **bind**(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
* int **listen**(int sockfd, int backlog);
* int **connect**(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
* int **accept**(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
* ssize_t **recv**(int sockfd, void *buf, size_t len, int flags);
* ssize_t **send**(int sockfd, const void *buf, size_t len, int flags);
* ssize_t **read**(int fd, void *buf, size_t count);
* ssize_t **write**(int fd, const void *buf, size_t count);
* int **close**(int fd);

```c
//服务端：socket - bind - listen - accept - recv - close
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#define MAXLINE 4096

int main(int argc, char** argv)
{
	int    listenfd, connfd;
	struct sockaddr_in     servaddr;
	char    buff[MAXLINE];
	int     n;

	if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 )
	{
		printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);
		exit(0);
	}
	
	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(6666);

	if( bind(listenfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1)
	{
		printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);
		exit(0);
	}

	if( listen(listenfd, 10) == -1)
	{
		printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);
		exit(0);
	}

	printf("======waiting for client's request======\n");
	while(1)
	{
		if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1)
		{
			printf("accept socket error: %s(errno: %d)",strerror(errno),errno);
			continue;
		}
		n = recv(connfd, buff, MAXLINE, 0);
		buff[n] = '\0';
		printf("recv msg from client: %s\n", buff);
		close(connfd);
    }

    close(listenfd);
}
```

```c
 //客户端：socket - connect - send - close
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#define MAXLINE 4096

int main(int argc, char** argv)
{
	int    sockfd, n;
	char    recvline[MAXLINE], sendline[MAXLINE];
	struct sockaddr_in    servaddr;

	if( argc != 2)
	{
		printf("usage: ./client <ipaddress>\n");
		exit(0);
	}

	if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);
		exit(0);
	}

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(6666);
	if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
	{
		printf("inet_pton error for %s\n",argv[1]);
		exit(0);
	}

	if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0)
	{
		printf("connect error: %s(errno: %d)\n",strerror(errno),errno);
		exit(0);
	}

	printf("send msg to server: \n");
	fgets(sendline, MAXLINE, stdin);
	if( send(sockfd, sendline, strlen(sendline), 0) < 0)
	{
		printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);
		exit(0);
	}

	close(sockfd);
}
```

---

