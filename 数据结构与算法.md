数据结构就是一组数据的存储结构。算法就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。

# 线性表
### 数组
数组是连续的内存空间，用来存储一组相同类型的数据。数组具有高效随机访问的特征，但插入和删除低效。  
数组使用注意项：数组越界  
为什么数组下标要从0开始？从内存模型上看，数组的下标的含义是偏移。  

### 链表
链表是通过指针将一组零散的内存块串联在一起的数据结构，把这些内存块称作链表的节点。链表的插入、删除操作的高效的，但查找访问低效。   
应用：通过链表实现LRU（最近最少使用策略）淘汰缓存算法

* 单向链表
* 双向链表
* 循环链表（约瑟夫环问题）
* 双向循环链表
* 跳表

  跳表是一种基于链表实现二分查找的动态数据结构，支持快速插入、删除、查找的操作，时间复杂度是O(logn)。跳表的设计思路是使用空间换时间，通过多级索引来提高查询效率。与红黑树相比，实现上简单易懂。

### 栈
栈是一种操作受限的线性表，只允许在一端插入和删除数据，并且满足先进后出、后进先出的特性。栈只支持两个操作：入栈、出栈，也就是从栈顶插入或删除一个数据。栈可以用数组和链表来实现，分别叫做顺序栈和链式栈。  
栈的应用场景：函数调用、表达式求值、括号匹配、工具的前进后退功能。  

### 队列
队列是一种操作受限的线性表，满足先进先出的特性。只支持两个操作：入队，在队尾添加一个元素、出队，从队头取一个元素。队列可以用数组和链表来实现，分别叫做顺序队列和链式队列。  
队列的应用：对于资源有限的场景，当没有空闲资源时，可以通过队列来实现请求排队等待。例如：当线程池没有空闲线程的情况下，通过一个基于数组实现的有界阻塞队列，当新任务请求线程资源时，入队阻塞等待，等到有空闲线程时则任务出队分配线程资源。若队列中阻塞等待的任务请求超过了队列的大小，接下来的任务请求都会被拒绝。

* 循环队列
* 阻塞队列
* 并发队列
* 阻塞并发队列



# 散列表

散列表也叫哈希表，用的是数组支持下标随机访问数据的特性，所以散列表是数组的一种扩展，由数组演化而来。将键值通过散列函数映射转化为散列表，把散列表的值作为数组下标去存储数据。在查询时，同样将键值通过同个散列函数转化为数组下标，取得数据。  
散列表的两个核心问题的散列函数设计和散列冲突解决。散列函数的好坏决定了散列冲突的概率，影响着散列表的性能。  

### 散列函数
* 散列函数计算得到的散列值是一个非负整数
* 如果key1=key2，那么hash(key1)=hash(key2)
* 如果key1≠key2，那么hash(key1)≠hash(key2)
* 第三点会产生散列冲突，即便是MD5、SHA、CRC等再好的哈希算法，也无法避免散列冲突。解决散列冲突的方法：开放寻址法、链表法

### 哈希算法
定义：将任意长度的二进制值映射为固定长度的二进制串

1. 从哈希值不能反向推导出原始数据。（哈希算法也叫单向哈希算法）
2. 对输入数据敏感，哪怕值修改一个bit，得到的哈希值也大不相同。
3. 散列冲突概率要很小，不同的原始数据，哈希值相同的概率非常小。
4. 哈希算法的执行效率要尽量高效，针对较长的数据，也能快速计算出哈希值。



* 应用一：安全加密（常用加密算法：MD5、SHA）
* 应用二：唯一标识
* 应用三：数据校验
* 应用四：散列函数
* 应用五：负载均衡
* 应用六：数据分片
* 应用七：分布式存储



# 树

### 二叉树
* 完全二叉树
* 满二叉树
* 二叉查找树
* 平衡二叉树
* 平衡二叉查找树
    * AVL树
    * 红黑树
### 多路查找树
* B树
* B+树
* 2-3树
* 2-3-4树
### 堆
* 小顶堆
* 大顶堆
* 优先级队列
* 斐波那契堆
* 二顶堆



# 图

* 广度优先算法
* 深度优先算法



# 复杂度

* 空间复杂度
* 时间复杂度：最好、最坏、平均、均摊



# 排序

* O(n^2)
  * **冒泡排序**：比较两个数据，将大的数据交换到后面。
  * **插入排序**：将数据分为已排序区间、未排序区间，将未排序区间的数据一个个拿出来，比较后插入到已排序区间。（类似于插牌的习惯）
  * **选择排序**：将数据分为已排序区间、未排序区间，比较找到未排序区间的最小值，插入到已排序区间末尾。
  * **希尔排序**：将数据按一个间隔值取出，组成多个子序列，对每个序列进行插入排序。逐次递减间隔值，重复操作。
* O(nlogn)
  * **归并排序**：将数据从中间分解为前后两组，重复递归分解。对分解后的数据进行排序合并，重复递归合并。
  * **快速排序**：在数据区间中取一个分区点数据，比分区点小的数据放左边，比分区点大的数据放右边，对左右两边的数据重复递归操作。

  * **堆排序**
* O(n)
  * **桶排序**：将要排序的数据分到几个有序的桶里面，每个桶对数据单独进行排序，再把每个痛里面的数据按顺序取出。（如果数据极端分布不均匀，会造成桶内的排序算法O(n)退化。桶排序适合用在外部排序，数据量比较大，内存有限时，可以利用桶排序将数据存储到外部磁盘中。）
  * **计数排序**：可以理解为一种特殊的桶排序，对每个数据设置一个桶。适用于数据量比数据范围大很多的正整数排序。（给100万的考生分数排序）
  * **基数排序**：将每个数据分割成独立的位，位之间有递进的关系，对每个位进行稳定排序。（给10万个手机号排序）



# 查找

* 线性表查找
* 树结构查找
* 散列表查找



# 搜索

* 深度优先搜索
* 广度优先搜索
* A*启发式搜索



# 基本算法

* BF/RK字符串匹配算法
* **贪心算法**：针对一组数据，我们定义了限制值和期望值，从中选出几个数据，在满足限制值的情况下，期望值最大。
* **分治算法**：将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。（MapReduce）
* **回溯算法**：从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。
* **动态规划**：多阶段决策最优解模型。背包问题