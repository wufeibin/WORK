# Makefile

[跟我一起写Makefile](https://github.com/seisman/how-to-write-makefile) 

> make先找到makefile中的第一个目标文件，一层层去找target的依赖关系，执行command，最终编译出第一个目标文件。

编译过程：

1. 预处理：替换inclue内容，宏定义， gcc –E hello.c –o hello.i
2. 编译：生成汇编代码，gcc –S hello.i –o hello.s
3. 汇编：生成机器代码，gcc –c hello.s –o hello.o
4. 链接：链接目标文件，gcc hello.o –o hello

编译选项：

- -o 指定目标文件名称
- -c 生成目标文件
- -g 生成编译信息
- -O 优化生成代码
- -Wall 生成所有告警信息
- -I 指定额外的头文件搜素路径
- -L 指定额外的库搜索路径
- -l 指定链接的库名
- -M 生成文件关联的信息
- -share 生成共享目标文件
- -fPIC 生成位置独立的代码，编译共享库时需要
- -pipe 使用管道代替编译中的临时文件

```
//静态库编译
g++ -c hello.cpp
ar -crv libhello.a hello.o
//动态库编译
g++ -fPIC -share helo.cpp -o libhello.so
//静态库、动态库使用
g++ -c main.cpp -L./libpath -lhello
```

常见字符：

- @ 不打印命令，只打印结果
- % 匹配到若干个字符，给%赋值。%.o:%.c，找出匹配的所有的.o和.c文件
- $@ 目标文件
- $^ 所有的依赖文件
- $< 第一个依赖文件
- := 只能使用前面已定义的变量来赋值
- ?= 赋值一个新的变量，若变量已定义则不处理
- += 追加变量值
- CFLAGS C编译器参数
- CXXFLAGS C++编译器参数
- LDFLAGS 链接器参数
- .PHONY 伪目标，可开头声明一个all的伪目标，依赖多个目标，实现一次生成多个目标
- include 引用其他Makefile
- $(MAKE) -C subdir，进入subdir嵌套执行make命令
- strip函数，去掉字符串头尾的空字符，合并中间的连续空字符为一个空字符
- addprefix函数，给字符加前缀

Makefile样例：

```
CCFLAGS += 编译选项
LDFLAGS += 链接选项

GLOBAL_DEF += 宏定义
GLOBAL_DEF_F = $(addprefix -D, $(GLOBAL_DEF))

INCLUDES += 头文件路径
INCLUDES_F = $(addprefix -I, $(INCLUDES))

LIBS_DIRS += 库文件路径
LIBS_DIRS_F = $(addprefix -L, $(LIBS_DIRS))

LIBS_FILES += 库文件
LIBS_FILES_F = $(addprefix -l, $(LIBS_FILES))

SRC_FILES += 源文件
OBJ_FILES = $(SRC_FILES:%.cpp=%.o)


$(TARGET):$(OBJ_FILES)	链接生成目标文件
	@echo LD $(notdir $@)
	$(LD) $(LDFLAGS) $(LIBS_DIRS_F) $(LIBS_FILES_F) $^ -o $(TARGET)

%.o: %.cpp	编译所有源文件
	@echo CC "(" $(CXX) ")" $(notdir $<)
	$(CXX) $(CCFLAGS) $(GLOBAL_DEF_F) $(INCLUDES_F) -o $@ $<

clean:
	$(RM) $(OBJ_FILES) $(TARGET_BIN) 
```

- Q1：一个只声明未定义的库文件函数，模块引用编译会失败报错，模块不引用编译成功。链接阶段只查找使用的符号定义，未使用的符号不查找
- Q2：程序运行时若缺少无法找到动态库，程序运行失败报错。
- 静态链接：包含符号解析和重定位两个步骤，由静态链接器完成。静态库的缺点体现在内存资源和维护更新。
- 动态链接：
  - 装载时动态链接：使用头文件，类似静态库的调用，编译时就链接库，会在程序启动是就完成加载。
    - 静态链接器：生成部分链接的可执行目标文件，在编译链接时，添加依赖动态库的信息，生成目标文件包含一些重定位和符号表信息 ，可用ldd查看
    - 动态链接器：生成完全链接的可执行文件。程序开始运行时装载建立链接关系。
  - 运行时动态链接：不使用头文件，通过dlopen/dlsym加载动态库



- 编译时只是把函数的符号地址记录下来，链接时该函数符号有定义才会变成具体的地址。如果链接过程中所有使用的符号都有定义，链接成功，生成可执行文件；否则链接失败。 
- 静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。而动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息），仅当应用程序被装入内存开始运行时建立链接关系。

编译错误：

- 未声明：undeclared identifier

- 未定义：Undefined symbols



### CMAKE

https://blog.csdn.net/zhanghm1995/article/details/80902807




# GDB

- break file:line
- break function
- break ... if ...	//设置条件断点
- info breakpoints	//查看当前设置了哪些断点
- delete breakpoints	//删除断点
- enable/disable breakpoints	//启用/禁用断点
- display		//跟踪查看某个变量，每次遇到断点都显示它的值
- command	breakpoints ··· end	//为断点设置运行命令
- run			//从头开始连续运行程序
- continue	//从当前位置开始连续运行程序
- next		//执行下一行语句
- step		//执行下一行语句，若有函数调用则进入到函数中
- finish		//运行到当前函数返回为止
- backtrace	//查看各级函数调用及参数
- t ..		//跳转到指定线程
- f ..		//跳转到指定栈帧
- info locals	//查看当前栈帧局部变量的值
- info args	//查看当前函数入参的值
- info r		//查看寄存器的值
- print		//打印表达式的值
- disassemble //打开该帧函数的反汇编代码
- examine(x)	//按字节打印某个地址中开始的值
- thread apply all bt	//打印所有线程堆栈

- gdb attach pid
- gstack pid	//打印进程全部堆栈

