# 链接

### 静态链接

静态链接使开发者能够相对独立地开发测试程序模块，但随着程序规模扩大，静态链接出现**浪费内存和磁盘空间、模块更新困难**等缺点。

- 静态库编译

  ```
  g++ -c hello.cpp
  ar -crv libhello.a hello.o
  g++ -c main.cpp -L./libpath -lhello //链接
  ```

### 动态链接

为了解决静态链接空间浪费和更新困难的问题，动态链接的基本思路是，把程序拆分成各个相对独立的模块，在运行时进行链接。运行时根据程序的依赖关系，将需要的目标文件（动态库）全部加载到内存中；若依赖关系满足，系统开始进行链接工作（符号解析、地址重定位）；链接后再将控制权交到程序入口处。

- 动态库编译

  ```
  g++ -fPIC -share helo.cpp -o libhello.so
  g++ -c main.cpp -L./libpath -lhello //链接
  ```


- 装载时动态链接：使用头文件，类似静态库的调用，编译时就链接库，会在程序启动是就完成加载。

  - 静态链接器：生成部分链接的可执行目标文件，在编译链接时[ld]，添加依赖动态库的信息，生成目标文件包含一些重定位和符号表信息 ，可用ldd查看

  - 动态链接器：生成完全链接的可执行文件。程序开始运行时装载建立链接关系。
- 运行时动态链接：不使用头文件，通过dlopen/dlsym加载动态库
  - 插件：按照一定的规则制定好程序的接口，其他开发者以接口规范来编写符合要求的动态链接文件，程序运行时可以动态地选择加载各种插件，实现程序功能的扩展。

- Q1：一个只声明未定义的库文件函数，模块引用编译会失败报错，模块不引用编译成功。链接阶段只查找使用的符号定义，未使用的符号不查找
- Q2：程序运行时若缺少或无法找到动态库，程序运行失败报错。

- 编译时只是把函数的符号地址记录下来，链接时该函数符号有定义才会变成具体的地址。如果链接过程中所有使用的符号都有定义，链接成功，生成可执行文件；否则链接失败。 
- 静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。而动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息），仅当应用程序被装入内存开始运行时建立链接关系。

### 共享库

- 共享库版本命名：libname.so.x.y.z
  - x 主版本号：重大升级，不兼容
  - y 次版本号：增量升级，新增接口符号，原有符号不变
  - z 发布版本号：错误修正，性能改进，完全兼容
- SO-NAME：只保留主版本号。Linux系统中会为每个共享库所在的目录创建一个跟SO-NAM同名的并指向它的软链接。
- 共享库系统路径
  - /lib：存放系统最关键最基础的共享库，如动态链接器、C运行库、数学库
  - /usr/lib：存放非系统运行时的关键性共享库，一般不会被用户程序直接使用
- 共享库查找过程
  - 动态链接器会在 /lib 和 /usr/lib 和 /etc/ld.so.conf 配置文件指定路径查找共享库。
  - 通过LD_LIBRARY_PATH环境变量，临时改变程序的共享库查找路径。



# Makefile

[跟我一起写Makefile](https://github.com/seisman/how-to-write-makefile) 

> make先找到makefile中的第一个目标文件，一层层去找target的依赖关系，执行command，最终编译出第一个目标文件。

**编译过程：**

1. 预处理：替换inclue内容，宏定义， gcc –E hello.c –o hello.i
2. 编译：生成汇编代码，gcc –S hello.i –o hello.s
3. 汇编：生成机器代码，gcc –c hello.s –o hello.o
4. 链接：链接目标文件，gcc hello.o –o hello

**编译选项：**

- -o 指定目标文件名称
- -c 生成目标文件
- -g 生成编译信息
- -O 优化生成代码
- -Wall 生成所有告警信息
- -I 指定额外的头文件搜素路径
- -L 指定额外的库搜索路径
- -l 指定链接的库名
- -M 生成文件关联的信息
- -share 生成共享目标文件
- -fPIC 生成位置独立的代码，编译共享库时需要
- -pipe 使用管道代替编译中的临时文件

**常见字符：**

- @ 不打印命令，只打印结果
- % 匹配到若干个字符，给%赋值。%.o:%.c，找出匹配的所有的.o和.c文件
- $@ 目标文件
- $^ 所有的依赖文件
- $< 第一个依赖文件
- := 只能使用前面已定义的变量来赋值
- ?= 赋值一个新的变量，若变量已定义则不处理
- += 追加变量值
- CFLAGS C编译器参数
- CXXFLAGS C++编译器参数
- LDFLAGS 链接器参数
- .PHONY 伪目标，可开头声明一个all的伪目标，依赖多个目标，实现一次生成多个目标
- include 引用其他Makefile
- $(MAKE) -C subdir，进入subdir嵌套执行make命令
- strip函数，去掉字符串头尾的空字符，合并中间的连续空字符为一个空字符
- addprefix函数，给字符加前缀

**Makefile样例：**

```
CCFLAGS += 编译选项
LDFLAGS += 链接选项

GLOBAL_DEF += 宏定义
GLOBAL_DEF_F = $(addprefix -D, $(GLOBAL_DEF))

INCLUDES += 头文件路径
INCLUDES_F = $(addprefix -I, $(INCLUDES))

LIBS_DIRS += 库文件路径
LIBS_DIRS_F = $(addprefix -L, $(LIBS_DIRS))

LIBS_FILES += 库文件
LIBS_FILES_F = $(addprefix -l, $(LIBS_FILES))

SRC_FILES += 源文件
OBJ_FILES = $(SRC_FILES:%.cpp=%.o)


$(TARGET):$(OBJ_FILES)	链接生成目标文件
	@echo LD $(notdir $@)
	$(LD) $(LDFLAGS) $(LIBS_DIRS_F) $(LIBS_FILES_F) $^ -o $(TARGET)

%.o: %.cpp	编译所有源文件
	@echo CC "(" $(CXX) ")" $(notdir $<)
	$(CXX) $(CCFLAGS) $(GLOBAL_DEF_F) $(INCLUDES_F) -o $@ $<

clean:
	$(RM) $(OBJ_FILES) $(TARGET_BIN) 
```

**编译错误：**

- 未声明：undeclared identifier

- 未定义：Undefined symbols



### CMAKE

https://blog.csdn.net/zhanghm1995/article/details/80902807




# GDB

- break file:line
- break function
- break ... if ...	//设置条件断点
- info breakpoints	//查看当前设置了哪些断点
- delete breakpoints	//删除断点
- enable/disable breakpoints	//启用/禁用断点
- display		//跟踪查看某个变量，每次遇到断点都显示它的值
- command	breakpoints ··· end	//为断点设置运行命令
- run			//从头开始连续运行程序
- continue	//从当前位置开始连续运行程序
- next		//执行下一行语句
- step		//执行下一行语句，若有函数调用则进入到函数中
- finish		//运行到当前函数返回为止
- backtrace	//查看各级函数调用及参数
- t ..		//跳转到指定线程
- f ..		//跳转到指定栈帧
- info locals	//查看当前栈帧局部变量的值
- info args	//查看当前函数入参的值
- info r		//查看寄存器的值
- print		//打印表达式的值
- disassemble //打开该帧函数的反汇编代码
- examine(x)	//按字节打印某个地址中开始的值
- thread apply all bt	//打印所有线程堆栈

- gdb attach pid
- info locals
- gstack pid	//打印进程全部堆栈
- set print pretty
- info sharedlibrary
- add-symbol-file 符号表 地址
- set solib-search-path 路径
