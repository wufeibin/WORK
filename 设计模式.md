# 单一职责原则
* 两种设计的单一职责：接口设计和类设计。
* 建议：接口设计一定要做到单一职责，而类设计尽量只有一个原因引起变化。
* 优点：类的复杂性降低，实现什么职责都有清晰明确的定义。变更引起的连锁反应风险降低。
* 难点：职责是很难划分的


# 里氏替换原则
* 定义一：如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换为o2时，程序P的行为没有发生变化，那么类型S就是类型T的子类。
* 定义二：所有使用基类的地方必须能透明的使用其子类的对象。（便于理解）
* 使用规范
    * 子类必须完全实现父类的方法
    * 子类可以有自己的个性
    * 覆盖和实现父类的方法时，输入参数可以被放大，但不能被缩小。
    * 覆盖和实现父类的方法时，输出结果可以被缩小，但不能被放大。


# 依赖倒置原则
* 要求：实现依赖于抽象，而抽象不依赖于实现。
* 优点
    * 不必为某一具体个体定制特别的处理函数，避免大量的函数重载。
    * 依赖倒置原则可以降低类间的耦合度。
* 依赖的实现方法
    * 构造函数
    * setter方法（一个设置成员属性的值的函数）
    * 接口声明注入


# 接口隔离原则
* 所谓接口就是抽象
* 单一职责原则是从业务角度上来对类进行接口的抽象和细分，而接口隔离原则是从代码角度来对接口进行细分。因为单一职责原则得到的接口可能比较庞大，这就需要我们进行接口隔离原则的实施了。
* 使用规范：接口要尽量小、接口要高内聚


# 最少知道原则（迪米特法则）
* 一个对象应该对其他对象有最少的了解。


# 开闭原则
* 对扩展开放，对修改关闭。
* 开闭原则是最基础的原则。前5个原则都是开闭原则的具体形态。


# 单例模式
单例模式是使用最广泛的设计模式，其意图是保证一个类仅有一个实例，并提供一个全局访问接口。
* 饿汉模式：立即加载，在类初始化时主动创建实例。由于在所有线程执行前初始化，不用考虑线程安全。但在部分情况下，可能使用不到单例也被初始化了，造成性能浪费。
```c++
class Single
{
private:
	Single(){};
	~Single(){};
	static Single m_Ins;
public:
	static Single* GetInstance();
	{
		return &m_Ins;
	}
}
Single Single::m_Ins;	//定义为静态成员变量，main执行前静态初始化过程中对象已经被分配
```
* 懒汉模式：延迟加载，第一次使用时创建实例。
```c++
class Single
{
private:
	Single(){};
	~Single(){};
	Single m_Ins;
public:
	Single* GetInstance()	//方法一：new对象时，存在线程安全问题
	{
		static Single* m_Ins = NULL;
		if(m_Ins == NULL)	//多个线程同时进入，可能会创建出多个对象实例
		{
			m_Ins = new Single();
		}
		return m_Ins;
	}
	Single* GetInstance()	//方法二：使用局部静态变量
	{
		static Single m_Ins;	//C++11标准保证了static变量初始化的线程安全
		return &m_Ins;
	}
	Single* GetInstance()	//方法三：双检查锁
	{
		static Single* m_Ins = NULL;
		if(m_Ins == NULL)	//防止多个线程获取单例时阻塞，添加此判断，提高效率
		{
			Lock()	//加锁，防止多个线程同时进入创建实例，解决线程安全问题
			if(m_Ins == NULL)
			{
				m_Ins = new Single();	
				//但其实此处仍存在问题。第一个线程开始new对象实例时，分配了对象内存空间后，指针指向了对象，但是还未将对象初始化；此时第二个线程来获取单例，能获取成功，但是去访问单例对象时会出错。
			}
			UnLock()
		}
		return m_Ins;
	}
}
```


# 工厂模式
[三种工厂模式的C++实现](https://blog.csdn.net/silangquan/article/details/20492293)
* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式


# 观察者模式
一个被观察者对象Subject的状态发生改变，通知所有的观察者Observer对象。  
配置是被观察者/通知者，当配置发生变化，利用signal通知观察者（各业务回调处）。

```c++
#include <iostream>
#include <string>
#include <list>
using namespace std;
 
class Subject;
class Observer	//抽象观察者
{
protected:
	string name;
	Subject *sub;
public:
	Observer(string name, Subject *sub)
	{
		this->name = name;
		this->sub = sub;
	}
	virtual void update() = 0;
};
class StockObserver :public Observer	//具体的观察者，看股票的
{
public:
	StockObserver(string name, Subject *sub) :Observer(name, sub){}
	void update()
	{
		cout << name << " 收到消息：" << sub->action << endl;
		if (sub->action == "梁所长来了！")
		{
			cout << "我马上关闭股票，装做很认真工作的样子！" << endl;
		}
	}
};
class NBAObserver :public Observer	//具体的观察者，看NBA的
{
public:
	NBAObserver(string name, Subject *sub) :Observer(name, sub){}
	void update()
	{
		cout << name << " 收到消息：" << sub->action << endl;
		if (sub->action == "梁所长来了！")
		{
			cout << "我马上关闭NBA，装做很认真工作的样子！" << endl;
		}
	}
};


class Subject	//抽象被观察者
{
protected:
	list<Observer*> observers;
public:
	string action;
	virtual void attach(Observer*) = 0;
	virtual void detach(Observer*) = 0;
	virtual void notify() = 0;
};
class SecretarySubject :public Subject	//具体被观察者，秘书发出通知
{
	void attach(Observer *observer)
	{
		observers.push_back(observer);
	}
	void detach(Observer *observer)
	{
		list<Observer *>::iterator iter = observers.begin();
		while (iter != observers.end())
		{
			if ((*iter) == observer)
			{
				observers.erase(iter);
			}
			++iter;
		}
	}
	void notify()
	{
		list<Observer *>::iterator iter = observers.begin();
		while (iter != observers.end())
		{
			(*iter)->update();
			++iter;
		}
	}
};

 
int main()
{
	Subject *sub = new SecretarySubject();
	Observer *xs = new NBAObserver("xiaoshuai", sub);
	Observer *zy = new NBAObserver("zouyue", sub);
	Observer *lm = new StockObserver("limin", sub);

	sub->attach(xs);
	sub->attach(zy);
	sub->attach(lm);

	sub->action = "去吃饭了！";
	sub->notify();

	sub->action = "梁所长来了！";
	sub->notify();
	return 0;
}
```