> 数据结构就是一组数据的存储结构。算法就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。

# 数据结构 - 线性表

## 数组
数组是连续的内存空间，用来存储一组相同类型的数据。数组具有高效随机访问的特征，但插入和删除低效。

为什么数组下标要从0开始？从内存模型上看，数组的下标的含义是偏移。  

## 链表

链表是通过指针将一组零散的内存块串联在一起的数据结构，把这些内存块称作链表的节点。链表的插入、删除操作的高效的，但查找访问低效。

* 单向链表

<img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom:50%;" />

* 双向链表

<img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom:50%;" />

* 循环链表

<img src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg" alt="img" style="zoom:50%;" />

* 跳表

  跳表是一种基于链表实现二分查找的动态数据结构，支持快速插入、删除、查找的操作，时间复杂度是O(logn)。跳表的设计思路是使用空间换时间，通过多级索引来提高查询效率。

<img src="https://static001.geekbang.org/resource/image/d0/0c/d03bef9a64a0368e6a0d23ace8bd450c.jpg" alt="img" style="zoom:50%;" />

## 栈

<img src="https://static001.geekbang.org/resource/image/3e/0b/3e20cca032c25168d3cc605fa7a53a0b.jpg" alt="img" style="zoom:50%;" />

栈是一种操作受限的线性表，只允许在一端插入和删除数据，并且满足先进后出、后进先出的特性。栈只支持两个操作：入栈、出栈，也就是从栈顶插入或删除一个数据。栈可以用数组和链表来实现，分别叫做顺序栈和链式栈。

栈的应用：函数调用、表达式求值、括号匹配、工具的前进后退功能。  

## 队列

<img src="https://static001.geekbang.org/resource/image/9e/3e/9eca53f9b557b1213c5d94b94e9dce3e.jpg" alt="img" style="zoom:50%;" />

队列是一种操作受限的线性表，满足先进先出的特性。只支持两个操作：入队，在队尾添加一个元素、出队，从队头取一个元素。队列可以用数组和链表来实现，分别叫做顺序队列和链式队列。

队列的应用：对于资源有限的场景，当没有空闲资源时，可以通过队列来实现请求排队等待。例如：当线程池没有空闲线程的情况下，通过一个基于数组实现的有界阻塞队列，当新任务请求线程资源时，入队阻塞等待，等到有空闲线程时则任务出队分配线程资源。若队列中阻塞等待的任务请求超过了队列的大小，接下来的任务请求都会被拒绝。

* 循环队列
* 阻塞队列
* 并发队列
* 阻塞并发队列



# 数据结构 - 散列表

<img src="https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg" alt="img" style="zoom:50%;" />

```
HashFunction(Key) = index, table[index] = Key
```

散列表也叫哈希表，用的是数组支持下标随机访问数据的特性，所以散列表是数组的一种扩展，由数组演化而来。将键值通过散列函数映射转化为散列表，把散列表的值作为数组下标去存储数据。在查询时，同样将键值通过同个散列函数转化为数组下标，取得数据。


## 散列函数
将任意长度的二进制值映射为固定长度的二进制串

**特性**：

* 从哈希值不能反向推导出原始数据。对输入数据敏感，哪怕值修改一个bit，得到的哈希值也大不相同。
* 如果key1=key2，那么hash(key1)=hash(key2)；如果key1≠key2，那么hash(key1)≠hash(key2)。
* 即便是MD5、SHA、CRC等再好的哈希算法也无法避免产生散列冲突。散列冲突概率要很小，散列函数的好坏决定了散列冲突的概率，影响着散列表的性能。
* 哈希算法的执行效率要尽量高效，针对较长的数据，也能快速计算出哈希值。

**设计方法**：

- 除法散列法

  关键字 Key 映射到 m 个槽中的某一位置，散列函数为：`h(Key) = Key mod m`，其中 m 不应是 2 的幂，通常 m 的值是与 2 的整数幂不太接近的质数。`table[h(Key)] = Key`

- 乘法散列法

  用关键字 key 乘上常数 A(0<A<1)，并抽取出 `key*A` 的小数部分。用 m 乘以这个抽取出来的小数，再对乘积向下取整(floor)。散列函数为：`h(Key) = floor(m*(Key*A mod 1))`； 其中 mod 1 的意思就是取小数部分。 `Key*A mod 1` 即为 `Key*A - floor(Key*A)`。

  乘法散列法的优点是对 m 的选择没什么特别的要求。一般选 m 为 2 的某次幂(2^p，p为某个整数)

## 散列冲突

再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。

1. 开放寻址法：如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。

<img src="https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt="img" style="zoom:50%;" />

2. 链表法：每个桶（bucket）或者槽（slot）会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

<img src="https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="img" style="zoom:50%;" />



# 数据结构 - 树

## 二叉树

<img src="https://static001.geekbang.org/resource/image/09/2b/09c2972d56eb0cf67e727deda0e9412b.jpg" alt="img" style="zoom:50%;" />

* **满二叉树**：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。（2）
* **完全二叉树**：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。（3）
* **二叉查找树**：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
* **平衡二叉树**：二叉树中任意一个节点的左右子树的高度相差不能大于1。
* **平衡二叉查找树**：AVL树、红黑树



<img src="https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg" alt="img" style="zoom:50%;" />

1. **前序遍历**：对任意节点，先打印**节点本身**，然后再打印它的左子树，最后打印它的右子树。
2. **中序遍历**：对任意节点，先打印它的左子树，然后再打印**节点本身**，最后打印它的右子树。
3. **后序遍历**：对任意节点，先打印它的左子树，然后再打印它的右子树，最后打印**节点本身**。

## 多路查找树

* B树
* B+树
* 2-3-4树

## 堆

<img src="https://static001.geekbang.org/resource/image/4c/99/4c452a1ad3b2d152daa2727d06097099.jpg" alt="img" style="zoom:50%;" />

堆其实就是一棵完全二叉树，父节点的值比每一个子节点的值都要大/小。

* 大顶堆：堆顶元素为最大项（1、2）
* 小顶堆：堆顶元素为最小项（3）



# 数据结构 - 图

## 类型

**无向图、无向权重图、有向图、有向权重图**

![Screen Shot 2019-10-26 at 09.09.02.png](https://cdn.nlark.com/yuque/0/2019/png/536542/1572052520887-08e08e9d-3880-4a22-a441-8ef17b4156d3.png?x-oss-process=image%2Fresize%2Cw_1500)

图中的节点我们称为顶点(Vertex)其缩写为 `V`，边(Edge)缩写为 `E`。另外，顶点和边还有一个概念叫**度**(degree)表示一个顶点相邻边数，而**有向图**中如果存在顶点 A 有一条指向顶点 B 的边，则对于顶点 B 这条边称为**入度**，相反，对于顶点 A 这条边则称为**出度**。

我们日常使用的微信中记录的好友关系则可以使用**无向图**表示；如果有玩过王者荣耀，则对游戏中的好友之间的亲密度不陌生，好友关系及亲密度则可以使用**无向权重图**表示；还有我们的微博和现在使用的语雀中的关注功能表示两个用户的单向关系则可以使用**有向图**表示；如果你有一部手机，那么必不可少的就是导航软件，其中的地图就可以使用使用**有向权重图**表示两个地点的方向和两个地点的距离。

## 表示方法

- **邻接矩阵(Adjacency Matrices)**

![邻接矩阵](https://cdn.nlark.com/yuque/0/2019/png/536542/1572053000977-9e65e7c4-8db5-480b-a7c2-f328c05566d8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_RWR3YXJkIExlZSBKYW4%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1500)

邻接矩阵的**优点**是查找快捷，如果给定一个 `edge(i,j)` 的边，则可直接在矩阵中通过 `graph[i][j]` 查询。直观且表现力强，**无向图**中为 1 的数字总是对称，而对于**无向权重图**则是非 0 的数字总是对称。

邻接矩阵的**缺点**是在矩阵中存在较多的值为 0 的元素时，这些多余元素的存在明显占据着额外的内存，这对于稀疏图来说十分不友好。

- **邻接表(Adjacency Lists)**

![邻接表](https://cdn.nlark.com/yuque/0/2019/png/536542/1572053043709-79c79b5f-ec55-4558-81f0-f7dcb583e350.png?x-oss-process=image%2Fresize%2Cw_1500)

邻接表的优势是既省空间且计算和查询速度更快。

现在再来计算一个顶点度数(边数)或获取该顶点对应**出度**的所有顶点，首先需要说明的是散列表查询一个顶点的时间复杂度是 `O(1)`，我们发现度数就是链表的长度，所以时间复杂度是 `O(1)`，获取**出度**的所有顶点，其时间复杂度是 `O(D)`，D 为顶点的度数(degree)，值范围是 `0 <= D <= V`。其空间复杂度又是多少呢？以**无向图**为例计算，所有顶点需要一个数组记录，且每个顶点对应储存的列表与度(degree)有关，因此需要的空间复杂度为 `O(V+D)`。

- **逆邻接表(Inverse Adjacency Lists)**

邻接表似乎已经很完美了，但我们要是换一个问题，把获取该顶点对应**出度**的所有顶点改为获取该顶点对应**入度**的所有顶点。这个时候邻接表就用不上了，如果使用暴力遍历的方式效率也会非常低下，时间复杂度也会变得很高。如果我们把**有向图**中的**出度**和**入度**互换，相当于将方向逆转，以**有向权重图**为例，参考下图**逆邻接表**的构造过程。

![逆邻接表](https://cdn.nlark.com/yuque/0/2019/png/536542/1572141717364-42da68e8-b34e-432e-a1b0-8845dcf7a4d7.png?x-oss-process=image%2Fresize%2Cw_1500)

以微博作为实际例子，顶点的**出度**表示用户关注另一个用户，顶点的**入度**表示用户被关注，如果**邻接表**能计算出一个用户关注的所有用户，那**逆邻接表**就能计算出关注该用户的所有用户。

## 遍历搜索

* **广度优先搜索BFS**：从图的一个未访问的顶点 V 开始，先遍历这个节点的相邻节点，再依遍次历每个相邻节点的相邻节点。

<img src="https://static001.geekbang.org/resource/image/00/ea/002e9e54fb0d4dbf5462226d946fa1ea.jpg" alt="img" style="zoom:50%;" />

* **深度优先搜索DFS**：从图中一个未访问的顶点 V 开始，沿着一条路走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底，不断递归重复此过程，直到所有的顶点都遍历完成。

<img src="https://static001.geekbang.org/resource/image/87/85/8778201ce6ff7037c0b3f26b83efba85.jpg" alt="img" style="zoom:50%;" />



# 算法 - [排序](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.md)

**O(n^2)**

* **冒泡排序**：比较两个数据，将大的数据交换到后面。
* **插入排序**：将数据分为已排序区间、未排序区间，将未排序区间的数据一个个拿出来，比较后插入到已排序区间。（类似于插牌的习惯）
* **选择排序**：将数据分为已排序区间、未排序区间，比较找到未排序区间的最小值，插入到已排序区间末尾。
* **希尔排序**：将数据按一个间隔值取出，组成多个子序列，对每个序列进行插入排序。逐次递减间隔值，重复操作。

**O(nlogn)**

* **归并排序**：将数据从中间分解为前后两组，重复递归分解。对分解后的数据进行排序合并，重复递归合并。
* **快速排序**：在数据区间中取一个分区点数据，比分区点小的数据放左边，比分区点大的数据放右边，对左右两边的数据重复递归操作。
* **堆排序**：将数据构建成一个大顶堆；将堆顶元素与末尾元素交换，最大元素沉到数组末端；重新调整剩余数据使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。

**O(n)**

* **桶排序**：将要排序的数据分到几个有序的桶里面，每个桶对数据单独进行排序，再把每个痛里面的数据按顺序取出。（如果数据极端分布不均匀，会造成桶内的排序算法O(n)退化。桶排序适合用在外部排序，数据量比较大，内存有限时，可以利用桶排序将数据存储到外部磁盘中。）
* **计数排序**：可以理解为一种特殊的桶排序，对每个数据设置一个桶。适用于数据量比数据范围大很多的正整数排序。（给100万的考生分数排序）
* **基数排序**：将每个数据分割成独立的位，位之间有递进的关系，对每个位进行稳定排序。（给10万个手机号排序）



# 算法 - 查找/搜索

* 线性表查找
* 散列表查找
* 树结构查找
* 广度优先搜索BFS
* 深度优先搜索DFS
* 启发式搜索
* [最短路径算法](https://www.yuque.com/edwardleejan/algorithm/dijkstra)：迪杰斯特拉(Dijkstra)算法



# 算法 - 链表

```java
// 单链表节点的结构
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

## 递归反转整个链表

<img src="https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.jpg" alt="img" style="zoom:50%;" />

```c
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```

我们的 `reverse` 函数定义是这样的：输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点。

<img src="https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.jpg" alt="img" style="zoom:50%;" />

<img src="https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/3.jpg" alt="img" style="zoom:50%;" />

<img src="https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/4.jpg" alt="img" style="zoom:50%;" />

<img src="https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/5.jpg" alt="img" style="zoom:50%;" />

## 反转链表前 N 个节点

这次我们实现一个这样的函数：将链表的前 n 个节点反转（n <= 链表长度）

```java
ListNode reverseN(ListNode head, int n)
```

比如说对于下图链表，执行 `reverseN(head, 3)`：

<img src="https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/6.jpg" alt="img" style="zoom:50%;" />

解决思路和反转整个链表差不多，只要稍加修改即可：

```java
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
}    
```

## 反转链表的一部分

现在解决我们最开始提出的问题，给一个索引区间 `[m,n]`（索引从 1 开始），仅仅反转区间中的链表元素。

```java
ListNode reverseBetween(ListNode head, int m, int n)
```

首先，如果 `m == 1`，就相当于反转链表开头的 `n` 个元素嘛，也就是我们刚才实现的功能：

```java
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        // 相当于反转前 n 个元素
        return reverseN(head, n);
    }
    // ...
}
```

如果 `m != 1` 怎么办？如果我们把 `head` 的索引视为 1，那么我们是想从第 `m` 个元素开始反转对吧；如果把 `head.next` 的索引视为 1 呢？那么相对于 `head.next`，反转的区间应该是从第 `m - 1` 个元素开始的；那么对于 `head.next.next` 呢……

区别于迭代思想，这就是递归思想，所以我们可以完成代码：

```java
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}
```



## K 个一组反转链表

我们对这个链表调用 `reverseKGroup(head, 2)`，即以 2 个节点为一组反转链表：

<img src="https://labuladong.gitee.io/algo/images/kgroup/1.jpg" alt="img" style="zoom:50%;" />

如果我设法把前 2 个节点反转，那么后面的那些节点怎么处理？后面的这些节点也是一条链表，而且规模（长度）比原来这条链表小，这就叫**子问题**。

<img src="https://labuladong.gitee.io/algo/images/kgroup/5.jpg" alt="img" style="zoom:50%;" />

我们可以直接递归调用 `reverseKGroup(cur, 2)`，因为子问题和原问题的结构完全相同，这就是所谓的递归性质。

```c
// 反转区间 [a, b) 的元素，注意是左闭右开
ListNode reverse(ListNode a, ListNode b) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    // while 终止的条件改一下就行了
    while (cur != b) {
        nxt = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}

ListNode reverseKGroup(ListNode head, int k) {
    if (head == null) return null;
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode a, b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) return head;
        b = b.next;
    }
    // 反转前 k 个元素
    ListNode newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
}
```



# 算法 - 二叉树

```c
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

**递归**算法的秘诀：明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

```c
// 定义：count(root) 返回以 root 为根的树有多少节点
int count(TreeNode root) {
    // base case
    if (root == null) return 0;
    // 自己加上子树的节点数就是整棵树的节点数
    return 1 + count(root.left) + count(root.right);
}
```

**快速排序**就是个二叉树的前序遍历

```c
void sort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    int p = partition(nums, lo, hi);
    /************************/

    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}
```

**归并排序**就是个二叉树的后序遍历

```c
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
    /************************/
}
```

## 翻转二叉树

```
输入一个二叉树根节点 root，让你把整棵树镜像翻转，比如输入的二叉树如下：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
算法原地翻转二叉树，使得以 root 为根的树变成：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

通过观察，我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情。

```c
// 将整棵树的节点翻转
TreeNode invertTree(TreeNode root) {
    // base case
    if (root == null) {
        return null;
    }

    /**** 前序遍历位置 ****/
    // root 节点需要交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 让左右子节点继续翻转它们的子节点
    invertTree(root.left);
    invertTree(root.right);
    
    return root;
}
```

## 填充二叉树节点右侧指针

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/title1.png" alt="img" style="zoom: 50%;" />

题目的意思就是把二叉树的每一层节点都用 `next` 指针连接起来：

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/1.png" alt="img" style="zoom:50%;" />

把每一层的节点穿起来，是不是只要把每个节点的左右子节点都穿起来就行了？

```c
Node connect(Node root) {
    if (root == null || root.left == null) {
        return root;
    }

    root.left.next = root.right;

    connect(root.left);
    connect(root.right);

    return root;
}
```

节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。

回想刚才说的，**二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情**，但是如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。

那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」：

```c
// 主函数
Node connect(Node root) {
    if (root == null) return null;
    connectTwoNode(root.left, root.right);
    return root;
}

// 辅助函数
void connectTwoNode(Node node1, Node node2) {
    if (node1 == null || node2 == null) {
        return;
    }
    /**** 前序遍历位置 ****/
    // 将传入的两个节点连接
    node1.next = node2;
    
    // 连接相同父节点的两个子节点
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接跨越父节点的两个子节点
    connectTwoNode(node1.right, node2.left);
}
```

## 将二叉树展开为链表

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/title2.png" alt="img" style="zoom:50%;" />

我们尝试给出这个函数的定义：**给 `flatten` 函数输入一个节点 `root`，那么以 `root` 为根的二叉树就会被拉平为一条链表**。

1、将 `root` 的左子树和右子树拉平。

2、将 `root` 的右子树接到左子树下方，然后将整个左子树作为右子树。

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/2.jpeg" alt="img" style="zoom:50%;" />

```c
// 定义：将以 root 为根的树拉平为链表
void flatten(TreeNode root) {
    // base case
    if (root == null) return;
    
    flatten(root.left);
    flatten(root.right);

    /**** 后序遍历位置 ****/
    // 1、左右子树已经被拉平成一条链表
    TreeNode left = root.left;
    TreeNode right = root.right;
    
    // 2、将左子树作为右子树
    root.left = null;
    root.right = left;

    // 3、将原先的右子树接到当前右子树的末端
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```

## 构造最大二叉树

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/title1.png" alt="img" style="zoom:50%;" />

**对于构造二叉树的问题，根节点要做的就是把想办法把自己构造出来**。我们肯定要遍历数组把找到最大值 `maxVal`，把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归调用，作为 `root` 的左右子树。

按照题目给出的例子，输入的数组为 `[3,2,1,6,0,5]`，对于整棵树的根节点来说，其实在做这件事：

```c
TreeNode constructMaximumBinaryTree(int[] nums) {
    if (nums is empty) return null;
    // 找到数组中的最大值
    int maxVal = Integer.MIN_VALUE;
    int index = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > maxVal) {
            maxVal = nums[i];
            index = i;
        }
    }

    TreeNode root = new TreeNode(maxVal);
    // 递归调用构造左右子树
    root.left = constructMaximumBinaryTree(nums[0..index-1]);
    root.right = constructMaximumBinaryTree(nums[index+1..nums.length-1]);
    return root;
}
```

对于每个根节点，只需要找到当前 `nums` 中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可。

```c
/* 主函数 */
TreeNode constructMaximumBinaryTree(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

/* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
TreeNode build(int[] nums, int lo, int hi) {
    // base case
    if (lo > hi) {
        return null;
    }

    // 找到数组中的最大值和对应的索引
    int index = -1, maxVal = Integer.MIN_VALUE;
    for (int i = lo; i <= hi; i++) {
        if (maxVal < nums[i]) {
            index = i;
            maxVal = nums[i];
        }
    }

    TreeNode root = new TreeNode(maxVal);
    // 递归调用构造左右子树
    root.left = build(nums, lo, index - 1);
    root.right = build(nums, index + 1, hi);
    
    return root;
}
```

## 前序和中序遍历结果构造二叉树

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6HLh9gbjia7hJ8O78PJKJWzicpA5mIeKwZtLUIq3msx2lFibOREdlpR7icg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

遍历顺序差异，导致了`preorder`和`inorder`数组中的元素分布有如下特点：

<img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6zvlia07hHvYB5JTKLTHCAmDW9I8dX8c8LmSo1ibejUHGibgH6zhMXBCmw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```c
/* 主函数 */
TreeNode buildTree(int[] preorder, int[] inorder) {
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}

/* 
前序遍历数组为 preorder[preStart..preEnd]，
后续遍历数组为 postorder[postStart..postEnd]，
构造二叉树，返回该二叉树的根节点 
*/
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);

    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);
    return root;
}
```

对于`inorder`数组的起始索引和终止索引比较容易确定：

<img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6BFJp9KicjbvfTdvhU3vaDFEqaUiaNF1q3HzkyFjnpypG8XrGzJXdpeLg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```c
root.left = build(preorder, ?, ?,
                  inorder, inStart, index - 1);
root.right = build(preorder, ?, ?,
                   inorder, index + 1, inEnd);
```

对于`preorder`数组，可以通过左子树的节点数推导出来，假设左子树的节点数为`leftSize`，那么`preorder`数组上的索引情况是这样的：

<img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6Awr35eI0tibAJ2qW6pDUpgWTv5icgDhRhniaIJg3dpYib7Ph5kqDneL08A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```c
int leftSize = index - inStart;
root.left = build(preorder, preStart + 1, preStart + leftSize,
                  inorder, inStart, index - 1);
root.right = build(preorder, preStart + leftSize + 1, preEnd,
                   inorder, index + 1, inEnd);
```

## 后序和中序遍历结果构造二叉树

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6MRJ8lXFDiaiaKT4GVOH9naRTbJCJOkJbbeyTguZpfpeOI5p6TcT0aRYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

遍历顺序差异，导致了`postorder`和`inorder`数组中的元素分布有如下特点：

<img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W6zY92ZAhsc8ZWZibYnWFlw25FrWlaq3SI5PFSdiaicsrRMRtpt437uNEiag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

现在`postoder`和`inorder`对应的状态如下：

<img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdF8ZItXTVByS26EcqBSS9W69FBqxDsQzHQ0BRzWVicAEyqw2seUxPQic0aJyDFicb2xnP08oD0bPcgeA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

```c
TreeNode buildTree(int[] inorder, int[] postorder) {
    return build(inorder, 0, inorder.length - 1,
                 postorder, 0, postorder.length - 1);
}

TreeNode build(int[] inorder, int inStart, int inEnd,
               int[] postorder, int postStart, int postEnd) {

    if (inStart > inEnd) {
        return null;
    }
    // root 节点对应的值就是后序遍历数组的最后一个元素
    int rootVal = postorder[postEnd];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    // 左子树的节点个数
    int leftSize = index - inStart;
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(inorder, inStart, index - 1,
                        postorder, postStart, postStart + leftSize - 1);

    root.right = build(inorder, index + 1, inEnd,
                        postorder, postStart + leftSize, postEnd - 1);
    return root;
}
```

## 二叉树的序列化与反序列化

给你输入一棵二叉树的根节点 `root`，要求你实现如下一个类：

```java
public class Codec {

    // 把一棵二叉树序列化成字符串
    public String serialize(TreeNode root) {}

    // 把字符串反序列化成二叉树
    public TreeNode deserialize(String data) {}
}
```

我们可以用 `serialize` 方法将二叉树序列化成字符串，用 `deserialize` 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。

以**前序遍历**为例：

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ba%8f%e5%88%97%e5%8c%96/1.jpeg" alt="img" style="zoom:50%;" />

```c
String SEP = ",";
String NULL = "#";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序遍历位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 `node` 列表包含空指针的信息，所以只使用 `node` 列表就可以还原二叉树。

```c
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    // 将字符串转化成列表
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    /****** 前序遍历位置 ******/
    // 列表最左侧就是根节点
    String first = nodes.removeFirst();
    if (first.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));
    /***********************/

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}
```

## 寻找重复子树

<img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%913/title.png" alt="img" style="zoom:50%;" />

从某一个节点去看，需要知道以下两点信息：

1. 以我为根的这棵二叉树（子树）长啥样？
2. 以其他节点为根的子树都长啥样？

那应该怎么描述一棵二叉树的模样呢？我们可以通过拼接字符串的方式把二叉树序列化，看下代码：

```c
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + "," + right + "," + root.val;
    return subTree;
}
```

我们用非数字的特殊符`#`表示空指针，并且用字符`,`分隔每个二叉树节点值。

接着，我们借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，就可以知道有没有其他节点的子树和自己重复了。

```c
// 记录所有子树以及出现的次数
HashMap<String, Integer> memo = new HashMap<>();
// 记录重复的子树根节点
LinkedList<TreeNode> res = new LinkedList<>();

/* 主函数 */
List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    return res;
}

/* 辅助函数 */
String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }

    String left = traverse(root.left);
    String right = traverse(root.right);

    String subTree = left + "," + right+ "," + root.val;

    int freq = memo.getOrDefault(subTree, 0);
    // 多次重复也只会被加入结果集一次
    if (freq == 1) {
        res.add(root);
    }
    // 给子树对应的出现次数加一
    memo.put(subTree, freq + 1);
    return subTree;
}
```

## BST 转化累加树

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/gibkIz0MVqdHhbIiaKVgQmmRicyibctQHKeFgNC21oJ9oC6xicLmWw9giaoVfWOWwP1RtdxYCDAdSCza7Rc2IF09TXSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

题目理解，比如图中的节点 5，转化成累加树的话，比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8=26。

BST 的中序遍历代码可以**升序**打印节点的值，如果想**降序**打印节点的值怎么办，只要把递归顺序改一下就行了。

```c
TreeNode convertBST(TreeNode root) {
    traverse(root);
    return root;
}

// 记录累加和
int sum = 0;
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.right);
    // 维护累加和
    sum += root.val;
    // 将 BST 转化成累加树
    root.val = sum;
    traverse(root.left);
}
```

## BST 的合法性

先上错误代码：

```c
boolean isValidBST(TreeNode root) {
    if (root == null) return true;
    if (root.left != null && root.val <= root.left.val)
        return false;
    if (root.right != null && root.val >= root.right.val)
        return false;

    return isValidBST(root.left)
        && isValidBST(root.right);
}
```

出现问题的原因在于，对于每一个节点 `root`，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，`root` 的整个左子树都要小于 `root.val`，整个右子树都要大于 `root.val`。

```c
boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) 
        && isValidBST(root.right, root, max);
}
```

## BST 中搜索一个数

如果是在二叉树中寻找元素，可以这样写代码：

```java
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target) return true;
    // 当前节点没找到就递归地去左右子树寻找
    return isInBST(root.left, target)
        || isInBST(root.right, target);
}
```

这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有普通二叉树。那么应该如何充分利用信息，把 BST 这个「左小右大」的特性用上？

很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 `target` 和 `root.val` 的大小比较，就能排除一边。我们把上面的思路稍稍改动：

```java
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target)
        return true;
    if (root.val < target) 
        return isInBST(root.right, target);
    if (root.val > target)
        return isInBST(root.left, target);
    // root 该做的事做完了，顺带把框架也完成了，妙
}
```

于是，我们对原始框架进行改造，抽象出一套**针对 BST 的遍历框架**：

```java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

## BST 中插入一个数

对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。

上一个问题，我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。一旦涉及「改」，函数就要返回 `TreeNode` 类型，并且对递归调用的返回值进行接收。

```java
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);
    // if (root.val == val)
    //     BST 中一般不会插入已存在元素
    if (root.val < val) 
        root.right = insertIntoBST(root.right, val);
    if (root.val > val) 
        root.left = insertIntoBST(root.left, val);
    return root;
}
```

## BST 中删除一个数

这个问题稍微复杂，跟插入操作类似，先「找」再「改」，先把框架写出来再说：

```java
TreeNode deleteNode(TreeNode root, int key) {
    if (root.val == key) {
        // 找到啦，进行删除
    } else if (root.val > key) {
        // 去左子树找
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        // 去右子树找
        root.right = deleteNode(root.right, key);
    }
    return root;
}
```

找到目标节点了，比方说是节点 `A`，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。

**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。

<img src="https://labuladong.gitee.io/algo/images/BST/bst_deletion_case_1.png" alt="img" style="zoom: 25%;" />

```java
if (root.left == null && root.right == null)
    return null;
```

**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。

<img src="https://labuladong.gitee.io/algo/images/BST/bst_deletion_case_2.png" alt="img" style="zoom:50%;" />

```java
// 排除了情况 1 之后
if (root.left == null) return root.right;
if (root.right == null) return root.left;
```

**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。

<img src="https://labuladong.gitee.io/algo/images/BST/bst_deletion_case_3.png" alt="img" style="zoom: 50%;" />

```java
if (root.left != null && root.right != null) {
    // 找到右子树的最小节点
    TreeNode minNode = getMin(root.right);
    // 把 root 改成 minNode
    root.val = minNode.val;
    // 转而去删除 minNode
    root.right = deleteNode(root.right, minNode.val);
}
```

三种情况分析完毕，填入框架，简化一下代码：

```java
TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        // 这两个 if 把情况 1 和 2 都正确处理了
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // 处理情况 3
        TreeNode minNode = getMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

TreeNode getMin(TreeNode node) {
    // BST 最左边的就是最小的
    while (node.left != null) node = node.left;
    return node;
} 
```

## 不同的二叉搜索树

给你输入一个正整数 `n`，请你计算，存储 `{1,2,3...,n}` 这些值共有多少种不同的 BST 结构构建出所有合法的 BST。比如说输入 `n = 3`，算法返回 5，因为共有如下 5 种不同的 BST 结构存储 `{1,2,3}`：

<img src="https://labuladong.gitee.io/algo/images/BST3/2.jpg" alt="img" style="zoom: 67%;" />

举个例子，比如给算法输入 `n = 5`，也就是说用 `{1,2,3,4,5}` 这些数字去构造 BST。首先，这棵 BST 的根节点总共有几种情况？显然有 5 种情况对吧，因为每个数字都可以作为根节点。

比如说我们固定 `3` 作为根节点，这个前提下能有几种不同的 BST 呢？根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。所以如果固定 `3` 作为根节点，左子树节点就是 `{1,2}` 的组合，右子树就是 `{4,5}` 的组合。**左子树的组合数和右子树的组合数乘积**就是 `3` 作为根节点时的 BST 个数。

<img src="https://labuladong.gitee.io/algo/images/BST3/1.jpeg" alt="img" style="zoom:50%;" />

```c
// 备忘录
int[][] memo;

int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    return count(1, n);
}

int count(int lo, int hi) {
    if (lo > hi) return 1;
    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }
    
    int res = 0;
    for (int mid = lo; mid <= hi; mid++) {
        int left = count(lo, mid - 1);
        int right = count(mid + 1, hi);
        res += left * right;
    }
    // 将结果存入备忘录
    memo[lo][hi] = res;
    
    return res;
}
```



# 算法 - 动态规划

多阶段决策最优解模型。背包问题



# 算法 - 回溯

从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。



# 算法 - 贪心

针对一组数据，我们定义了限制值和期望值，从中选出几个数据，在满足限制值的情况下，期望值最大。



# 算法 - 分治

将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。（MapReduce）







# 参考资料

- [labuladong 的算法小抄](https://labuladong.gitee.io/algo/)
- [常用树总结](https://blog.csdn.net/baichoufei90/article/details/84788524)
- [复杂度分析](https://www.yuque.com/edwardleejan/algorithm/complexity)

