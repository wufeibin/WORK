> 数据结构就是一组数据的存储结构。算法就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。



# 数据结构 - 线性表

## 数组
数组是连续的内存空间，用来存储一组相同类型的数据。数组具有高效随机访问的特征，但插入和删除低效。

为什么数组下标要从0开始？从内存模型上看，数组的下标的含义是偏移。  

## 链表
链表是通过指针将一组零散的内存块串联在一起的数据结构，把这些内存块称作链表的节点。链表的插入、删除操作的高效的，但查找访问低效。

链表的应用：通过链表实现LRU（最近最少使用策略）淘汰缓存算法

* 单向链表
* 双向链表
* 循环链表：约瑟夫环问题
* 跳表：跳表是一种基于链表实现二分查找的动态数据结构，支持快速插入、删除、查找的操作，时间复杂度是O(logn)。跳表的设计思路是使用空间换时间，通过多级索引来提高查询效率。


## 栈
栈是一种操作受限的线性表，只允许在一端插入和删除数据，并且满足先进后出、后进先出的特性。栈只支持两个操作：入栈、出栈，也就是从栈顶插入或删除一个数据。栈可以用数组和链表来实现，分别叫做顺序栈和链式栈。

栈的应用：函数调用、表达式求值、括号匹配、工具的前进后退功能。  

## 队列
队列是一种操作受限的线性表，满足先进先出的特性。只支持两个操作：入队，在队尾添加一个元素、出队，从队头取一个元素。队列可以用数组和链表来实现，分别叫做顺序队列和链式队列。

队列的应用：对于资源有限的场景，当没有空闲资源时，可以通过队列来实现请求排队等待。例如：当线程池没有空闲线程的情况下，通过一个基于数组实现的有界阻塞队列，当新任务请求线程资源时，入队阻塞等待，等到有空闲线程时则任务出队分配线程资源。若队列中阻塞等待的任务请求超过了队列的大小，接下来的任务请求都会被拒绝。

* 循环队列
* 阻塞队列
* 并发队列
* 阻塞并发队列



# 数据结构 - 散列表

散列表也叫哈希表，用的是数组支持下标随机访问数据的特性，所以散列表是数组的一种扩展，由数组演化而来。将键值通过散列函数映射转化为散列表，把散列表的值作为数组下标去存储数据。在查询时，同样将键值通过同个散列函数转化为数组下标，取得数据。

散列表的两个核心问题的散列函数设计和散列冲突解决。

散列表的应用：安全加密（常用加密算法：MD5、SHA）、唯一标识、数据校验、负载均衡、数据分片、分布式存储


## 散列/哈希函数
定义：将任意长度的二进制值映射为固定长度的二进制串

* 从哈希值不能反向推导出原始数据。对输入数据敏感，哪怕值修改一个bit，得到的哈希值也大不相同。
* 如果key1=key2，那么hash(key1)=hash(key2)；如果key1≠key2，那么hash(key1)≠hash(key2)。
* 会产生散列冲突，即便是MD5、SHA、CRC等再好的哈希算法也无法避免。散列冲突概率要很小，散列函数的好坏决定了散列冲突的概率，影响着散列表的性能。
* 哈希算法的执行效率要尽量高效，针对较长的数据，也能快速计算出哈希值。



# 数据结构 - 树

## 二叉树
* 完全二叉树
* 满二叉树
* 二叉查找树
* 平衡二叉树
* 平衡二叉查找树：AVL树、红黑树

## 多路查找树
* B树
* B+树
* 2-3-4树

## 堆

堆其实就是一棵完全二叉树，父节点的值比每一个子节点的值都要大/小。

* 大顶堆：堆顶元素为最大项
* 小顶堆：堆顶元素为最小项



# 数据结构 - 图

## 类型

**无向图、无向权重图、有向图、有向权重图**

![Screen Shot 2019-10-26 at 09.09.02.png](https://cdn.nlark.com/yuque/0/2019/png/536542/1572052520887-08e08e9d-3880-4a22-a441-8ef17b4156d3.png?x-oss-process=image%2Fresize%2Cw_1500)

图中的节点我们称为顶点(Vertex)其缩写为 `V`，边(Edge)缩写为 `E`。另外，顶点和边还有一个概念叫**度**(degree)表示一个顶点相邻边数，而**有向图**中如果存在顶点 A 有一条指向顶点 B 的边，则对于顶点 B 这条边称为**入度**，相反，对于顶点 A 这条边则称为**出度**。

我们日常使用的微信中记录的好友关系则可以使用**无向图**表示；如果有玩过王者荣耀，则对游戏中的好友之间的亲密度不陌生，好友关系及亲密度则可以使用**无向权重图**表示；还有我们的微博和现在使用的语雀中的关注功能表示两个用户的单向关系则可以使用**有向图**表示；如果你有一部手机，那么必不可少的就是导航软件，其中的地图就可以使用使用**有向权重图**表示两个地点的方向和两个地点的距离。

## 表示方法

- **邻接矩阵(Adjacency Matrices)**

![邻接矩阵](https://cdn.nlark.com/yuque/0/2019/png/536542/1572053000977-9e65e7c4-8db5-480b-a7c2-f328c05566d8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_RWR3YXJkIExlZSBKYW4%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1500)

邻接矩阵的**优点**是查找快捷，如果给定一个 `edge(i,j)` 的边，则可直接在矩阵中通过 `graph[i][j]` 查询。直观且表现力强，**无向图**中为 1 的数字总是对称，而对于**无向权重图**则是非 0 的数字总是对称。

邻接矩阵的**缺点**是在矩阵中存在较多的值为 0 的元素时，这些多余元素的存在明显占据着额外的内存，这对于稀疏图来说十分不友好。



- **邻接表(Adjacency Lists)**

![邻接表](https://cdn.nlark.com/yuque/0/2019/png/536542/1572053043709-79c79b5f-ec55-4558-81f0-f7dcb583e350.png?x-oss-process=image%2Fresize%2Cw_1500)

邻接表的优势是既省空间且计算和查询速度更快。

现在再来计算一个顶点度数(边数)或获取该顶点对应**出度**的所有顶点，首先需要说明的是散列表查询一个顶点的时间复杂度是 `O(1)`，我们发现度数就是链表的长度，所以时间复杂度是 `O(1)`，获取**出度**的所有顶点，其时间复杂度是 `O(D)`，D 为顶点的度数(degree)，值范围是 `0 <= D <= V`。其空间复杂度又是多少呢？以**无向图**为例计算，所有顶点需要一个数组记录，且每个顶点对应储存的列表与度(degree)有关，因此需要的空间复杂度为 `O(V+D)`。



- **逆邻接表(Inverse Adjacency Lists)**

邻接表似乎已经很完美了，但我们要是换一个问题，把获取该顶点对应**出度**的所有顶点改为获取该顶点对应**入度**的所有顶点。这个时候邻接表就用不上了，如果使用暴力遍历的方式效率也会非常低下，时间复杂度也会变得很高。如果我们把**有向图**中的**出度**和**入度**互换，相当于将方向逆转，以**有向权重图**为例，参考下图**逆邻接表**的构造过程。

![逆邻接表](https://cdn.nlark.com/yuque/0/2019/png/536542/1572141717364-42da68e8-b34e-432e-a1b0-8845dcf7a4d7.png?x-oss-process=image%2Fresize%2Cw_1500)

以微博作为实际例子，顶点的**出度**表示用户关注另一个用户，顶点的**入度**表示用户被关注，如果**邻接表**能计算出一个用户关注的所有用户，那**逆邻接表**就能计算出关注该用户的所有用户。

## 遍历搜索

* **深度优先搜索DFS**：从图中一个未访问的顶点 V 开始，沿着一条路走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底，不断递归重复此过程，直到所有的顶点都遍历完成。
* **广度优先搜索BFS**：从图的一个未访问的顶点 V 开始，先遍历这个节点的相邻节点，再依遍次历每个相邻节点的相邻节点。



# 算法 - [排序](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.md)

**O(n^2)**

* **冒泡排序**：比较两个数据，将大的数据交换到后面。
* **插入排序**：将数据分为已排序区间、未排序区间，将未排序区间的数据一个个拿出来，比较后插入到已排序区间。（类似于插牌的习惯）
* **选择排序**：将数据分为已排序区间、未排序区间，比较找到未排序区间的最小值，插入到已排序区间末尾。
* **希尔排序**：将数据按一个间隔值取出，组成多个子序列，对每个序列进行插入排序。逐次递减间隔值，重复操作。



**O(nlogn)**

* **归并排序**：将数据从中间分解为前后两组，重复递归分解。对分解后的数据进行排序合并，重复递归合并。
* **快速排序**：在数据区间中取一个分区点数据，比分区点小的数据放左边，比分区点大的数据放右边，对左右两边的数据重复递归操作。
* **堆排序**：将数据构建成一个大顶堆；将堆顶元素与末尾元素交换，最大元素沉到数组末端；重新调整剩余数据使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。



**O(n)**

* **桶排序**：将要排序的数据分到几个有序的桶里面，每个桶对数据单独进行排序，再把每个痛里面的数据按顺序取出。（如果数据极端分布不均匀，会造成桶内的排序算法O(n)退化。桶排序适合用在外部排序，数据量比较大，内存有限时，可以利用桶排序将数据存储到外部磁盘中。）
* **计数排序**：可以理解为一种特殊的桶排序，对每个数据设置一个桶。适用于数据量比数据范围大很多的正整数排序。（给100万的考生分数排序）
* **基数排序**：将每个数据分割成独立的位，位之间有递进的关系，对每个位进行稳定排序。（给10万个手机号排序）



# 算法 - 查找/搜索

* 线性表查找
* 散列表查找
* 树结构查找
* 深度优先搜索DFS
* 广度优先搜索BFS
* [最短路径算法](https://www.yuque.com/edwardleejan/algorithm/dijkstra)：迪杰斯特拉(Dijkstra)算法
* 启发式搜索



# 算法 - 动态规划

多阶段决策最优解模型。背包问题



# 算法 - 回溯

从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。



# 算法 - 贪心

针对一组数据，我们定义了限制值和期望值，从中选出几个数据，在满足限制值的情况下，期望值最大。



# 算法 - 分治

将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。（MapReduce）



# 参考资料

- **[labuladong 的算法小抄](https://github.com/labuladong/fucking-algorithm#labuladong-%E7%9A%84%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84)**
- [常见数据结构](https://cloud.tencent.com/developer/article/1634155)
- [常用树总结](https://blog.csdn.net/baichoufei90/article/details/84788524)
- [复杂度分析](https://www.yuque.com/edwardleejan/algorithm/complexity)