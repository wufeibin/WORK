[TOC]

> GitHub搜索：
>
> in:name/readme/description 关键词 language:python star:>1000 fork:>500 pushed:>2020-1-1 

# Kafka

## 1.简介

Kafka 是由 Linkedin 公司开发的，它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的**基于发布订阅模式的消息引擎系统**。

- **Producer**：生产者，push 消息到 Kafka 集群中的 broker 中；
- **Broker**：Kafka 集群由多个 Kafka 实例（server） 组成；
- **Topic**：producer 向 kafka 集群 push 的消息会被归于某一类别，即Topic，这本质上只是一个逻辑概念，面向的对象是 producer 和 consumer，producer 只需要关注将消息 push 到哪一个 Topic 中，而 consumer 只需要关心自己订阅了哪个 Topic；
- **Partition**：每一个 Topic 又被分为多个 Partitions，即物理分区；出于负载均衡的考虑，同一个 Topic 的 Partitions 分别存储于 Kafka 集群的多个 broker 上；而为了提高可靠性，这些 Partitions 可以由 Kafka 机制中的 replicas 来设置备份的数量；
- **Consumer**：消费者，从 Kafka 集群的 broker 中 pull 消息；



# Protobuf

##1.简介

protobuf（Protocol Buffers ）是 Google 的开源项目，是 Google 中立于语言、平台，可扩展的用于序列化结构化数据的解决方案。简单地说，protobuf 是用来对数据进行序列化和反序列化。

[官方文档](https://developers.google.com/protocol-buffers)

[GitHub源码](https://github.com/protocolbuffers/protobuf)

##2.使用

1. 定义proto文件，为需要序列化的数据结构添加一个消息（message），为消息中的每一个字段指定一个名字和类型。
2. 通过编译器编译proto文件，生成对应头文件（.pb.h ）和源文件（.pb.cc）
3. 使用生成的API读写消息

## 3.示例

- **tutorial.proto**

```
package tutorial;

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}
```

| proto 类型 | C++ 类型 |
| :--------- | :------- |
| double     | double   |
| float      | float    |
| int32      | int32    |
| uint32     | uint32   |
| int64      | int64    |
| uint64     | uint64   |
| sint32     | int32    |
| sint64     | sint64   |
| fixed32    | uint32   |
| fixed64    | uint64   |
| sfixed32   | int32    |
| sfixed64   | int64    |
| bool       | bool     |
| string     | string   |
| bytes      | string   |

> - 文件以一个 package 声明开始，可以避免不同项目的命名冲突。
> - 字段尾部的序号，用于二进制编码的唯一"标签"
> - required：必须提供字段值，否则会引起未初始化错误，序列化未初始化的消息会造成断言错误。
> - optional：可选提供字段值，当字段未被设置时取默认值。
> - repeated：可重复字段，类似于动态数组。

- protoc编译器：`protoc -I$SRC_DIR --cpp_out=$DST_DIR tutorial.proto`
- **tutorial.pb.h**

```c++
Person类
// name
inline bool has_name() const;
inline void clear_name();
inline const ::std::string& name() const;
inline void set_name(const ::std::string& value);
inline void set_name(const char* value);
inline ::std::string* mutable_name();

// id
inline bool has_id() const;
inline void clear_id();
inline int32_t id() const;
inline void set_id(int32_t value);

// email
inline bool has_email() const;
inline void clear_email();
inline const ::std::string& email() const;
inline void set_email(const ::std::string& value);
inline void set_email(const char* value);
inline ::std::string* mutable_email();

// phone
inline int phone_size() const;
inline void clear_phone();
inline const ::google::protobuf::RepeatedPtrField< ::tutorial::Person_PhoneNumber >& phone() const;
inline ::google::protobuf::RepeatedPtrField< ::tutorial::Person_PhoneNumber >* mutable_phone();
inline const ::tutorial::Person_PhoneNumber& phone(int index) const;
inline ::tutorial::Person_PhoneNumber* mutable_phone(int index);
inline ::tutorial::Person_PhoneNumber* add_phone();
```

```c++
bool SerializeToString(string* output) const;	//序列化消息写到字符串
bool ParseFromString(const string& data);	//从字符串解析消息
bool SerializeToArray(void * data, int size) const	//序列化消息至数组
bool ParseFromArray(const void * data, int size)	//从数组解析消息
bool SerializeToOstream(ostream* output) const;	//序列化消息写到 ostream
bool ParseFromIstream(istream* input);	//从 istream 解析消息
```

- **读写消息**

```c++
#include <iostream>
#include <fstream>
#include <string>
#include "tutorial.pb.h"
using namespace std;

void PromptForAddress(tutorial::Person* person) {
	person->mutable_name();
	person->set_id(1);
  person->set_email("xxx");
  tutorial::Person::PhoneNumber* phone_number = person->add_phone();
  phone_number->set_number("xxx");
  phone_number->set_type(tutorial::Person::MOBILE);
}

int main(int argc, char* argv[]) {
  // 在使用 C++ Protocol Buffer 库之前执行该宏。它可以保证避免不小心链接到一个与编译的头文件版本不兼容的库版本。如果被检查出来版本不匹配，程序将会终止。注意，每个 .pb.cc 文件在初始化时会自动调用这个宏。
  GOOGLE_PROTOBUF_VERIFY_VERSION;

	tutorial::AddressBook address_book;
  //写消息
  tutorial::Person* person;
  for(...) {
    person = address_book.add_person();
    person->mutable_name();
    person->set_id(1);
    person->set_email("xxx");
    tutorial::Person::PhoneNumber* phone_number = person->add_phone();
    phone_number->set_number("xxx");
    phone_number->set_type(tutorial::Person::MOBILE);   
  }
  fstream output(...);
  if (!address_book.SerializeToOstream(&output)) {
    cerr << "Failed to write address book." << endl;
    return -1;
  }
  
  //读消息
  fstream input(...);
  if (!address_book.ParseFromIstream(&input)) {
    cerr << "Failed to parse address book." << endl;
    return -1;
  }
  const tutorial::Person& person
  for (int i = 0; i < address_book.person_size(); i++) {
    person = address_book.person(i);
		person.id();
    person.name();
    person.has_email();
  }

  // 可选：释放 Protocol Buffer 库申请的所有全局对象
  google::protobuf::ShutdownProtobufLibrary();
  return 0;
}
```

- proto文件拓展

>  在扩展修改过程中，考虑到考兼容性问题，需注意以下几点：
>
> - 不可以修改任何已存在字段的标签数字
> - 不可以添加或删除任何 required 字段
> - 可以删除 optional 或 repeated 字段
> - 添加新的 optional 或 repeated 字段时，必须使用新的标签数字